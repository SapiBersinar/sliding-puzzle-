<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta name="keywords" content="sliding puzzle, puzzle geser, game puzzle, puzzle foto, game online, puzzle interaktif, potong gambar, gratis">
    <meta name="author" content="hanzercopy.cloud">
    
    <!-- Open Graph / Facebook / LinkedIn -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://hanzercopy.cloud">
    <meta property="og:title" content="Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!">
    <meta property="og:description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta property="og:image" content="https://placehold.co/1200x630/e0e7ff/4f46e5?text=Sliding%20Puzzle"> <!-- Ganti dengan URL gambar pratinjau Anda -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif';
            background-attachment: fixed; /* Memastikan gradient tetap saat scroll */
            overflow-x: hidden; /* Mencegah overflow horizontal */
            transition: background-color 0.3s ease, color 0.3s ease; /* Transisi tema */
        }
        /* Tema Terang (Default) */
        body.light-theme {
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1); /* Ungu-biru gradient */
            color: #1a202c; /* Teks gelap */
        }
        body.light-theme .main-container {
            background-color: #ffffff; /* Latar belakang putih */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        body.light-theme .text-primary {
            color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .text-secondary {
            color: #6b7280; /* Gray-500 */
        }
        body.light-theme .canvas-border {
            border-color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .canvas-bg {
            background-color: #ffffff;
        }
        body.light-theme .message-box, body.light-theme .confirmation-box, body.light-theme .cropper-content, body.light-theme #moveHistoryContainer, body.light-theme #playerStatsContainer, body.light-theme #movesPerTimeGraphContainer {
            background-color: #fff;
            border-color: #4f46e5;
        }
        body.light-theme #moveHistoryContainer, body.light-theme #playerStatsContainer, body.light-theme #movesPerTimeGraphContainer {
            background-color: #f8fafc;
        }
        body.light-theme .sample-image-container:hover {
            border-color: #6366f1;
        }
        body.light-theme .puzzle-solved-animation {
            border-color: #10b981; /* Green-500 */
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5);
        }
        body.light-theme .moves-time-text {
            color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .piece-number-color {
            color: #312e81; /* Darker indigo */
        }

        /* Tema Gelap */
        body.dark-theme {
            background-color: #1a202c; /* Darker background */
            background-image: none; /* Remove gradient */
            color: #e2e8f0; /* Light text */
        }
        body.dark-theme .main-container {
            background-color: #2d3748; /* Darker container */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }
        body.dark-theme .text-primary {
            color: #6366f1; /* Indigo-500, similar to light theme primary */
        }
        body.dark-theme .text-secondary {
            color: #a0aec0; /* Light gray */
        }
        body.dark-theme .canvas-border {
            border-color: #4f46e5; /* Indigo-600, similar to light theme */
        }
        body.dark-theme .canvas-bg {
            background-color: #2d3748; /* Darker canvas background */
        }
        body.dark-theme .message-box, body.dark-theme .confirmation-box, body.dark-theme .cropper-content, body.dark-theme #moveHistoryContainer, body.dark-theme #playerStatsContainer, body.dark-theme #movesPerTimeGraphContainer {
            background-color: #2d3748;
            border-color: #4f46e5; /* Indigo-600 */
            color: #e2e8f0;
        }
        body.dark-theme #moveHistoryContainer, body.dark-theme #playerStatsContainer, body.dark-theme #movesPerTimeGraphContainer {
            background-color: #1a202c;
        }
        body.dark-theme .sample-image-container:hover {
            border-color: #6366f1; /* Indigo-500 */
        }
        body.dark-theme .puzzle-solved-animation {
            border-color: #8b5cf6; /* Violet-500 for solved state */
            box-shadow: 0 0 20px 5px rgba(139, 92, 246, 0.7), 0 0 30px 10px rgba(139, 92, 246, 0.5); /* Glowing effect */
        }
        body.dark-theme .moves-time-text {
            color: #fff; /* White text for numbers */
        }
        body.dark-theme .piece-number-color {
            color: #a78bfa; /* Violet-400 */
        }

        /* Styling untuk canvas */
        canvas {
            display: block; /* Menghilangkan spasi ekstra di bawah canvas */
            border: 3px solid; /* Border */
            border-radius: 0.75rem; /* Sudut membulat */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: manipulation; /* Memungkinkan event sentuhan */
            -webkit-user-select: none; /* Non-seleksi teks untuk iOS */
            -moz-user-select: none; /* Non-seleksi teks untuk Firefox */
            -ms-user-select: none; /* Non-seleksi teks untuk IE/Edge */
            user-select: none; /* Non-seleksi teks */
            /* Transisi untuk animasi kemenangan */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        .message-box, .confirmation-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid; /* Border */
            width: 90%;
            max-width: 400px;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        /* Styling untuk tombol */
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Indigo ke Violet */
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Lebih gelap saat hover */
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6); /* Lebih gelap lagi saat ditekan */
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button Gradients for Shuffle/Replay */
        .dark-theme .btn-primary-gradient {
            background-image: linear-gradient(to right, #4A90E2, #6A5ACD); /* Vibrant Blue to Medium Purple */
        }
        .dark-theme .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #3A7CD1, #5A4ABF); /* Darker shades */
        }
        .dark-theme .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #2A6AB0, #4A3A9E); /* Even darker shades */
            transform: scale(0.98);
        }


        .btn-purple {
            background-color: #a855f7; /* Purple-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-purple:hover {
            background-color: #9333ea; /* Purple-600 */
        }
        .btn-purple:active {
            background-color: #7e22ce; /* Purple-700 saat ditekan */
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button for Undo */
        .dark-theme .btn-purple {
            background-color: #9370DB; /* MediumPurple */
        }
        .dark-theme .btn-purple:hover {
            background-color: #7B5ECF; /* Darker MediumPurple */
        }
        .dark-theme .btn-purple:active {
            background-color: #644CA3; /* Even Darker MediumPurple */
            transform: scale(0.98);
        }


        .btn-green-solve {
            background-color: #10b981; /* Green-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-green-solve:hover {
            background-color: #059669;
        }
        .btn-green-solve:active {
            background-color: #047857;
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button for Solve/Share */
        .dark-theme .btn-green-solve {
            background-image: linear-gradient(to right, #20B2AA, #3CB371); /* LightSeaGreen to MediumSeaGreen */
        }
        .dark-theme .btn-green-solve:hover {
            background-image: linear-gradient(to right, #1A908A, #329A5C); /* Darker shades */
        }
        .dark-theme .btn-green-solve:active {
            background-image: linear-gradient(to right, #146D66, #287A47); /* Even darker shades */
            transform: scale(0.98);
        }

        .btn-gray { /* General gray button for Reset */
            background-color: #6b7280; /* Gray-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .btn-gray:active {
            background-color: #374151; /* Gray-700 saat ditekan */
            transform: scale(0.98);
        }
        .dark-theme .btn-gray {
            background-color: #4a5568; /* Gray-700 */
        }
        .dark-theme .btn-gray:hover {
            background-color: #2d3748; /* Gray-800 */
        }
        .dark-theme .btn-gray:active {
            background-color: #1a202c; /* Gray-900 */
            transform: scale(0.98);
        }

        /* Styling untuk gambar contoh yang bisa diklik */
        .sample-image-container {
            width: 80px; /* Lebar tetap untuk gambar contoh */
            height: 80px; /* Tinggi tetap untuk gambar contoh */
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent; /* Border transparan default */
        }
        .sample-image-container:hover {
            transform: scale(1.05); /* Sedikit membesar saat hover */
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Pastikan gambar mengisi container tanpa distorsi */
            display: block;
        }


        /* Kelas untuk animasi kemenangan */
        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }

        /* Container untuk tampilan gambar asli di bawah */
        .original-image-display-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl; /* Match main container width */
        }
        .dark-theme .original-image-display-container {
            background-color: #2d3748;
        }
        .original-image-display-container.show {
            display: flex;
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0; /* Adjust margin if needed */
        }

        /* Kelas untuk menyembunyikan main-content saat gambar asli ditampilkan */
        .main-content-hidden {
            display: none;
        }

        /* Cropper Modal Styling */
        .cropper-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .cropper-content {
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #cropperCanvas {
            border: 2px solid;
            max-width: 100%;
            max-height: 60vh; /* Adjust as needed */
            display: block;
        }
        .light-theme #cropperCanvas {
            border-color: #6366f1;
            background-color: #f0f0f0;
        }
        .dark-theme #cropperCanvas {
            border-color: #4f46e5; /* Indigo-600 */
            background-color: #4a5568;
        }
        .cropper-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1002;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Move History Styling */
        #moveHistoryContainer {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid;
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            line-height: 1.5;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #moveHistoryList li {
            display: flex;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        #moveHistoryList li svg {
            margin-right: 0.5rem;
            flex-shrink: 0; /* Prevent SVG from shrinking */
        }

        /* Player Stats Styling */
        #playerStatsContainer {
            border: 1px solid;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #playerStatsContainer ul {
            list-style: none;
            padding: 0;
        }
        #playerStatsContainer li {
            margin-bottom: 0.5rem;
        }
        #playerStatsContainer li span {
            font-weight: 600;
        }

        /* Progress Indicator Styling */
        #progressIndicator {
            width: 100%;
            background-color: #e0e7ff; /* Light background for progress bar */
            border-radius: 9999px; /* Full rounded corners */
            height: 1.5rem; /* Height of the bar */
            overflow: hidden; /* Ensure inner bar stays within bounds */
            margin-bottom: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .dark-theme #progressIndicator {
            background-color: #4a5568; /* Darker background for dark theme */
        }

        #progressBar {
            height: 100%;
            width: 0%; /* Initial width */
            background-image: linear-gradient(to right, #818cf8, #6366f1); /* Blue-purple gradient */
            border-radius: 9999px;
            transition: width 0.5s ease-out; /* Smooth transition for width changes */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .dark-theme #progressBar {
            background-image: linear-gradient(to right, #4A90E2, #6A5ACD); /* Dark theme gradient */
        }
        #progressText {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }

        /* Confetti Canvas */
        #confettiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 1001; /* Above puzzle, below modals */
        }

        /* Moves Per Time Graph Styling */
        #movesPerTimeGraphContainer {
            margin-top: 1.5rem;
            padding: 1rem;
            border: 1px solid;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
            text-align: center;
        }
        #movesPerTimeGraphSVG {
            width: 100%;
            height: 150px; /* Fixed height for the graph */
            background-color: transparent; /* Background handled by container */
        }
        .moves-graph-line {
            fill: none;
            stroke-width: 2;
            transition: stroke 0.3s ease;
            stroke: #4f46e5; /* Default line color */
        }
        .dark-theme .moves-graph-line {
            stroke: #6366f1; /* Dark theme line color */
        }
        .moves-graph-point {
            r: 4;
            stroke-width: 1;
            fill: #4f46e5; /* Default point color */
            stroke: #3730a3; /* Darker stroke for points */
        }
        .dark-theme .moves-graph-point {
            fill: #6366f1;
            stroke: #4f46e5;
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div id="mainContent" class="w-full max-w-3xl p-6 rounded-xl main-container">
        <h1 class="text-3xl font-bold text-center text-primary mb-6" data-key="mainTitle">Sliding Puzzle Interaktif</h1>

        <div class="mb-6 text-center">
            <label for="themeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectTheme">Pilih Tema:</label>
            <select id="themeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                <option value="light" data-key="lightTheme">Terang</option>
                <option value="dark" data-key="darkTheme">Gelap</option>
            </select>
        </div>

        <div class="mb-6 text-center">
            <label for="languageSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectLanguage">Pilih Bahasa:</label>
            <select id="languageSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                <option value="en">English</option>
                <option value="id">Indonesia</option>
                <option value="es">Español</option>
                <option value="ja">日本語</option>
            </select>
        </div>

        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-secondary mb-2" data-key="uploadPhoto">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
        </div>

        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-secondary mb-2" data-key="orSelectSample">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png" alt="Contoh Gambar 1" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png" alt="Contoh Gambar 2" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png" alt="Contoh Gambar 3" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png" alt="Contoh Gambar 4" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <div class="text-center">
                <label for="gridSizeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectPuzzleSize">Pilih Ukuran Puzzle:</label>
                <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                    <option value="3" selected>3x3</option>
                    <option value="4">4x4</option>
                    <option value="5">5x5</option>
                    <option value="6">6x6</option> <!-- New -->
                    <option value="7">7x7</option> <!-- New -->
                </select>
            </div>

            <div class="text-center">
                <label for="puzzleModeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectPuzzleMode">Pilih Mode Puzzle:</label>
                <select id="puzzleModeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                    <option value="sliding" data-key="slidingPuzzle">Sliding Puzzle (Default)</option>
                    <option value="jigsaw" data-key="jigsaw">Jigsaw (Tanpa Nomor)</option>
                </select>
            </div>
        </div>

        <!-- New: Shuffle Strength Setting -->
        <div class="mb-6 text-center">
            <label for="shuffleStrengthInput" class="block text-lg font-medium text-secondary mb-2" data-key="shuffleStrength">Kekuatan Pengacakan (Gerakan):</label>
            <input type="number" id="shuffleStrengthInput" min="10" max="1000" value="220" 
                   class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600 w-32 text-center">
            <p class="text-sm text-secondary mt-1" data-key="shuffleStrengthHint">Jumlah gerakan acak untuk mengacak puzzle.</p>
        </div>

        <!-- New: Number Color Picker -->
        <div class="mb-6 text-center">
            <label for="numberColorPicker" class="block text-lg font-medium text-secondary mb-2" data-key="numberColor">Warna Angka:</label>
            <input type="color" id="numberColorPicker" value="#000000"
                   class="w-24 h-10 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent cursor-pointer">
            <p class="text-sm text-secondary mt-1" data-key="numberColorHint">Pilih warna untuk angka pada potongan puzzle.</p>
        </div>
        
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-secondary">
                <span data-key="moves">Gerakan</span>: <span id="moveCounter" class="moves-time-text">0</span>
            </div>
            <div class="text-lg font-semibold text-secondary">
                <span data-key="time">Waktu</span>: <span id="timerDisplay" class="moves-time-text">00:00</span>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" data-key="shuffle">
                Acak
            </button>
            <button id="undoButton" class="btn-purple text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2" data-key="undo">
                Urungkan
            </button>
            <button id="solveButton" class="btn-green-solve text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" data-key="autoSolve">
                Selesaikan Otomatis
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2" data-key="resetPuzzle">
                Reset Puzzle
            </button>
        </div>
        <div id="solveStatus" class="text-center text-red-600 font-medium mb-4" style="min-height: 24px;"></div>

        <!-- Progress Indicator -->
        <div id="progressIndicator">
            <div id="progressBar">
                <span id="progressText">0%</span>
            </div>
        </div>

        <div class="relative w-full max-w-full flex justify-center items-center overflow-hidden mb-6" style="min-height: 250px;">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full canvas-border canvas-bg"></canvas>
            <canvas id="confettiCanvas"></canvas> <!-- Confetti canvas overlay -->
        </div>

        <div class="text-center mt-4 flex flex-wrap justify-center gap-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2" data-key="viewOriginalImage">
                Lihat Gambar Asli
            </button>
            <button id="replayButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" style="display: none;" data-key="replayMoves">
                Putar Ulang Gerakan
            </button>
        </div>
        
        <p class="text-center text-secondary text-sm italic mt-4" data-key="clickHint">Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.</p>

        <div class="mt-6">
            <h2 class="text-xl font-semibold text-secondary mb-2 text-center" data-key="moveHistoryTitle">Riwayat Gerakan Anda:</h2>
            <div id="moveHistoryContainer" class="p-3 rounded-lg shadow-inner">
                <ul id="moveHistoryList" class="list-disc list-inside text-secondary">
                    <!-- Move history items will be appended here -->
                </ul>
            </div>
        </div>

        <!-- New: Moves Per Time Graph -->
        <div id="movesPerTimeGraphContainer">
            <h2 class="text-xl font-semibold text-secondary mb-2" data-key="movesPerTimeGraphTitle">Gerakan per Interval Waktu:</h2>
            <svg id="movesPerTimeGraphSVG"></svg>
        </div>

        <div id="playerStatsContainer" class="mt-6 p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold text-secondary mb-3 text-center" data-key="playerStatsTitle">Statistik Pemain:</h2>
            <ul class="text-secondary">
                <li><span data-key="totalGamesPlayed">Total Game Dimainkan</span>: <span id="statTotalGames" class="font-bold text-primary">0</span></li>
                <li><span data-key="totalTimePlayed">Total Waktu Bermain</span>: <span id="statTotalTime" class="font-bold text-primary">00:00:00</span></li>
                <li><span data-key="bestTime3x3">Waktu Terbaik (3x3)</span>: <span id="statBestTime3x3" class="font-bold text-primary">--:--</span></li>
                <li><span data-key="bestMoves3x3">Gerakan Terbaik (3x3)</span>: <span id="statBestMoves3x3" class="font-bold text-primary">--</span></li>
            </ul>
        </div>
        
    </div>

    <div id="messageBoxContainer"></div>
    <div id="confirmationBoxContainer"></div>

    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="backToPuzzle">
            Kembali ke Puzzle
        </button>
    </div>

    <!-- Cropper Modal -->
    <div id="imageCropperContainer" class="cropper-modal" style="display: none;">
        <div class="cropper-content">
            <h2 class="text-2xl font-bold text-center text-primary mb-4" data-key="cropAreaTitle">Pilih Area Puzzle</h2>
            <canvas id="cropperCanvas"></canvas>
            <div class="cropper-controls">
                <button id="confirmCropButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="confirmCrop">
                    Konfirmasi Potongan
                </button>
                <button id="cancelCropButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="cancel">
                    Batal
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p id="loadingMessage" data-key="loading">Memuat...</p>
    </div>


    <script type="module">
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const puzzleModeSelect = document.getElementById('puzzleModeSelect');
        const languageSelect = document.getElementById('languageSelect');
        const themeSelect = document.getElementById('themeSelect');
        const shuffleStrengthInput = document.getElementById('shuffleStrengthInput');
        const numberColorPicker = document.getElementById('numberColorPicker'); // New
        const shuffleButton = document.getElementById('shuffleButton');
        const undoButton = document.getElementById('undoButton');
        const solveButton = document.getElementById('solveButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const confirmationBoxContainer = document.getElementById('confirmationBoxContainer');
        const moveCounterDisplay = document.getElementById('moveCounter');
        const timerDisplay = document.getElementById('timerDisplay');
        const solveStatusDisplay = document.getElementById('solveStatus');
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent');
        const replayButton = document.getElementById('replayButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const moveHistoryList = document.getElementById('moveHistoryList');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const confettiCanvas = document.getElementById('confettiCanvas');
        const confettiCtx = confettiCanvas.getContext('2d');

        // Player Statistics elements
        const statTotalGames = document.getElementById('statTotalGames');
        const statTotalTime = document.getElementById('statTotalTime');
        const statBestTime3x3 = document.getElementById('statBestTime3x3');
        const statBestMoves3x3 = document.getElementById('statBestMoves3x3');

        // Cropper elements
        const imageCropperContainer = document.getElementById('imageCropperContainer');
        const cropperCanvas = document.getElementById('cropperCanvas');
        const cropperCtx = cropperCanvas.getContext('2d');
        const confirmCropButton = document.getElementById('confirmCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // Moves Per Time Graph elements
        const movesPerTimeGraphSVG = document.getElementById('movesPerTimeGraphSVG');
        const movesPerTimeGraphContainer = document.getElementById('movesPerTimeGraphContainer');

        // Sample image elements
        const sampleImageContainers = document.querySelectorAll('.sample-image-container');
        let originalImage = new Image();
        let puzzlePieces = [];
        let gridSize = parseInt(gridSizeSelect.value);
        let currentPuzzleMode = puzzleModeSelect.value;
        let currentLanguage = 'en';
        let currentTheme = 'light';
        let shuffleStrength = parseInt(shuffleStrengthInput.value);
        let numberColor = numberColorPicker.value; // New: Default number color
        const fixedCanvasSize = 1080;
        let pieceWidth;
        let pieceHeight;
        let blankPieceIndex;
        let isShuffled = false;
        let puzzleReady = false;
        let moves = 0;
        let isProcessingClick = false;
        let solving = false;
        let shuffling = false;
        let undoStack = [];
        const maxUndoStates = 50;

        let startTime;
        let timerInterval;
        let hasMadeFirstMove = false;
        const animationDuration = 200;
        
        let hoveredPieceIndex = -1;
        let currentBase64Image = '';

        const getAutoSolveStepDelay = (currentGridSize) => {
            if (currentGridSize <= 4) return 150;
            if (currentGridSize === 5) return 350;
            if (currentGridSize === 6) return 500;
            if (currentGridSize === 7) return 700;
            return 150;
        };
        
        const maxStatesToExploreForBFS = 1000000;

        // Cropping variables
        let cropRect = { x: 0, y: 0, size: 0 };
        let isDragging = false;
        let isResizing = false;
        let dragStartX, dragStartY;
        const resizeHandleSize = 10;

        // Source dimensions for puzzle pieces after cropping
        let finalSourceX = 0;
        let finalSourceY = 0;
        let finalSourceWidth = 0;
        let finalSourceHeight = 0;

        // Replay variables
        let replayMoves = [];
        let initialShuffledStateForReplay = [];
        let isReplaying = false;

        let moveHistory = []; // Stores { text: "...", direction: "..." }
        const maxMoveHistory = 10;

        // Moves per time graph data
        let movesPerIntervalData = []; // Stores { time: seconds, moves: count_in_interval }
        const graphUpdateInterval = 5; // seconds
        let lastRecordedTotalMoves = 0;
        let lastGraphUpdateTime = 0;


        // Player Statistics Object
        let playerStats = {
            totalGamesPlayed: 0,
            totalTimePlayedSeconds: 0,
            bestTime3x3Seconds: Infinity,
            bestMoves3x3: Infinity
        };

        // Confetti particles array
        let confettiParticles = [];
        let confettiAnimationId = null;

        // =====================================================================
        // Language Translations
        // =====================================================================
        const translations = {
            en: {
                mainTitle: "Interactive Sliding Puzzle",
                selectLanguage: "Select Language:",
                selectTheme: "Select Theme:",
                lightTheme: "Light",
                darkTheme: "Dark",
                uploadPhoto: "Upload Your Photo:",
                orSelectSample: "Or Select a Sample Image:",
                selectPuzzleSize: "Select Puzzle Size:",
                selectPuzzleMode: "Select Puzzle Mode:",
                shuffleStrength: "Shuffle Strength (Moves):",
                shuffleStrengthHint: "Number of random moves to shuffle the puzzle.",
                numberColor: "Number Color:", // New
                numberColorHint: "Choose a color for the numbers on puzzle pieces.", // New
                slidingPuzzle: "Sliding Puzzle (Default)",
                jigsaw: "Jigsaw (No Numbers)",
                moves: "Moves",
                time: "Time",
                shuffle: "Shuffle",
                undo: "Undo",
                autoSolve: "Auto Solve",
                resetPuzzle: "Reset Puzzle",
                viewOriginalImage: "View Original Image",
                replayMoves: "Replay Moves",
                clickHint: "Click a piece adjacent to the empty space to move it.",
                moveHistoryTitle: "Your Move History:",
                noMovesYet: "No moves yet.",
                backToPuzzle: "Back to Puzzle",
                cropAreaTitle: "Select Puzzle Area",
                confirmCrop: "Confirm Crop",
                cancel: "Cancel",
                loading: "Loading...",
                loadingImage: "Loading image...",
                loadingSampleImage: "Loading sample image...",
                failedLoadImage: "Failed to load image. Please ensure it's a valid image file.",
                failedLoadSampleImage: "Failed to load sample image. Please try again or upload your own image.",
                shufflingPuzzle: "Shuffling puzzle...",
                shuffleFail: (attempts) => `Failed to find a solvable puzzle after ${attempts} attempts. Try shuffling again.`,
                noUndo: "No moves to undo.",
                confirmReset: "Are you sure you want to reset the puzzle? Your progress will be lost.",
                uploadImageFirst: "Please upload an image first.",
                autoSolveConfirm: "Do you want the puzzle to be solved automatically? This will reset your moves.",
                autoSolveWarning5x5: "Warning: 5x5 Auto-Solve is Very Slow! Please be patient.",
                autoSolveWarning6x6: "Warning: 6x6 Auto-Solve is Extremely Slow! Please be patient.",
                autoSolveWarning7x7: "Warning: 7x7 Auto-Solve is Impractically Slow! Use with caution.",
                autoSolveSearching: "Searching for auto-solve solution...",
                solutionFound: (numMoves) => `Solution found! Playing ${numMoves} moves...`,
                errorPlayingSolution: "An error occurred while playing the solution.",
                solutionNotFound: "Solution not found within time/computation limits. Try shuffling again.",
                noReplayMoves: "No moves to replay.",
                replayFinished: "Replay finished.",
                puzzleSolved: (moves, time) => `Congratulations! Puzzle solved in ${moves} moves and ${time}!`,
                cropCancelled: "Cropping cancelled. Please upload or select another image.",
                noImageLoaded: "No image loaded to display.",
                pieceMoved: (pieceNumber, direction) => `Piece ${pieceNumber} moved ${direction}`,
                directionRight: "Right",
                directionLeft: "Left",
                directionDown: "Down",
                directionUp: "Up",
                playerStatsTitle: "Player Statistics:",
                totalGamesPlayed: "Total Games Played",
                totalTimePlayed: "Total Time Played",
                bestTime3x3: "Best Time (3x3)",
                bestMoves3x3: "Best Moves (3x3)",
                movesPerTimeGraphTitle: "Moves Per Time Interval:", // New
                notApplicable: "--",
                puzzleNotShuffled: "The puzzle is not shuffled yet. Please click 'Shuffle' to begin.",
            },
            id: {
                mainTitle: "Sliding Puzzle Interaktif",
                selectLanguage: "Pilih Bahasa:",
                selectTheme: "Pilih Tema:",
                lightTheme: "Terang",
                darkTheme: "Gelap",
                uploadPhoto: "Unggah Foto Anda:",
                orSelectSample: "Atau Pilih Gambar Contoh:",
                selectPuzzleSize: "Pilih Ukuran Puzzle:",
                selectPuzzleMode: "Pilih Mode Puzzle:",
                shuffleStrength: "Kekuatan Pengacakan (Gerakan):",
                shuffleStrengthHint: "Jumlah gerakan acak untuk mengacak puzzle.",
                numberColor: "Warna Angka:", // New
                numberColorHint: "Pilih warna untuk angka pada potongan puzzle.", // New
                slidingPuzzle: "Sliding Puzzle (Default)",
                jigsaw: "Jigsaw (Tanpa Nomor)",
                moves: "Gerakan",
                time: "Waktu",
                shuffle: "Acak",
                undo: "Urungkan",
                autoSolve: "Selesaikan Otomatis",
                resetPuzzle: "Reset Puzzle",
                viewOriginalImage: "Lihat Gambar Asli",
                replayMoves: "Putar Ulang Gerakan",
                clickHint: "Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.",
                moveHistoryTitle: "Riwayat Gerakan Anda:",
                noMovesYet: "Belum ada gerakan.",
                backToPuzzle: "Kembali ke Puzzle",
                cropAreaTitle: "Pilih Area Puzzle",
                confirmCrop: "Konfirmasi Potongan",
                cancel: "Batal",
                loading: "Memuat...",
                loadingImage: "Memuat gambar...",
                loadingSampleImage: "Memuat gambar contoh...",
                failedLoadImage: "Gagal memuat gambar. Pastikan ini adalah file gambar yang valid.",
                failedLoadSampleImage: "Gagal memuat gambar contoh. Silakan coba lagi atau unggah gambar Anda sendiri.",
                shufflingPuzzle: "Mengacak puzzle...",
                shuffleFail: (attempts) => `Gagal menemukan puzzle yang dapat dipecahkan setelah ${attempts} percobaan. Coba acak ulang.`,
                noUndo: "Tidak ada gerakan untuk di-undo.",
                confirmReset: "Apakah Anda yakin ingin mereset puzzle? Progres Anda akan hilang.",
                uploadImageFirst: "Silakan unggah gambar terlebih dahulu.",
                autoSolveConfirm: "Apakah Anda ingin puzzle diselesaikan secara otomatis? Ini akan mereset gerakan Anda.",
                autoSolveWarning5x5: "Peringatan: 5x5 Otomatis Sangat Lambat! Harap Bersabar.",
                autoSolveWarning6x6: "Peringatan: 6x6 Otomatis Sangat Lambat! Harap Bersabar.",
                autoSolveWarning7x7: "Peringatan: 7x7 Otomatis Sangat Tidak Praktis! Gunakan dengan hati-hati.",
                autoSolveSearching: "Mencari solusi otomatis...",
                solutionFound: (numMoves) => `Solusi ditemukan! Memainkan ${numMoves} gerakan...`,
                errorPlayingSolution: "Terjadi kesalahan saat memainkan solusi.",
                solutionNotFound: "Solusi tidak ditemukan dalam batas waktu/komputasi. Coba acak ulang.",
                noReplayMoves: "Tidak ada gerakan untuk diputar ulang.",
                replayFinished: "Pemutaran ulang selesai.",
                puzzleSolved: (moves, time) => `Selamat! Puzzle telah selesai dalam ${moves} gerakan dan waktu ${time}!`,
                cropCancelled: "Pemotongan dibatalkan. Silakan unggah atau pilih gambar lain.",
                noImageLoaded: "Tidak ada gambar yang dimuat untuk ditampilkan.",
                pieceMoved: (pieceNumber, direction) => `Potongan ${pieceNumber} bergerak ${direction}`,
                directionRight: "Kanan",
                directionLeft: "Kiri",
                directionDown: "Bawah",
                directionUp: "Atas",
                playerStatsTitle: "Statistik Pemain:",
                totalGamesPlayed: "Total Game Dimainkan",
                totalTimePlayed: "Total Waktu Bermain",
                bestTime3x3: "Waktu Terbaik (3x3)",
                bestMoves3x3: "Gerakan Terbaik (3x3)",
                movesPerTimeGraphTitle: "Gerakan per Interval Waktu:", // New
                notApplicable: "--",
                puzzleNotShuffled: "Puzzle belum diacak. Silakan klik 'Acak' untuk memulai.",
            },
            es: {
                mainTitle: "Rompecabezas Deslizante Interactivo",
                selectLanguage: "Seleccionar Idioma:",
                selectTheme: "Seleccionar Tema:",
                lightTheme: "Claro",
                darkTheme: "Oscuro",
                uploadPhoto: "Sube tu foto:",
                orSelectSample: "O Selecciona una Imagen de Ejemplo:",
                selectPuzzleSize: "Seleccionar Tamaño del Rompecabezas:",
                selectPuzzleMode: "Seleccionar Modo de Rompecabezas:",
                shuffleStrength: "Fuerza de Barajado (Movimientos):",
                shuffleStrengthHint: "Número de movimientos aleatorios para barajar el rompecabezas.",
                numberColor: "Color del Número:", // New
                numberColorHint: "Elige un color para los números en las piezas del rompecabezas.", // New
                slidingPuzzle: "Rompecabezas Deslizante (Predeterminado)",
                jigsaw: "Rompecabezas (Sin Números)",
                moves: "Movimientos",
                time: "Tiempo",
                shuffle: "Barajar",
                undo: "Deshacer",
                autoSolve: "Resolver Automáticamente",
                resetPuzzle: "Reiniciar Rompecabezas",
                viewOriginalImage: "Ver Imagen Original",
                replayMoves: "Reproducir Movimientos",
                clickHint: "Haz clic en una pieza adyacente al espacio vacío para moverla.",
                moveHistoryTitle: "Tu Historial de Movimientos:",
                noMovesYet: "Aún no hay movimientos.",
                backToPuzzle: "Volver al Rompecabezas",
                cropAreaTitle: "Seleccionar Área del Rompecabezas",
                confirmCrop: "Confirmar Recorte",
                cancel: "Cancelar",
                loading: "Cargando...",
                loadingImage: "Cargando imagen...",
                loadingSampleImage: "Cargando imagen de ejemplo...",
                failedLoadImage: "No se pudo cargar la imagen. Asegúrate de que sea un archivo de imagen válido.",
                failedLoadSampleImage: "No se pudo cargar la imagen de ejemplo. Inténtalo de nuevo o sube tu propia imagen.",
                shufflingPuzzle: "Barajando rompecabezas...",
                shuffleFail: (attempts) => `No se pudo encontrar un rompecabezas resoluble después de ${attempts} intentos. Intenta barajar de nuevo.",`,
                noUndo: "No hay movimientos para deshacer.",
                confirmReset: "¿Estás seguro de que quieres reiniciar el rompecabezas? Tu progreso se perderá.",
                uploadImageFirst: "Por favor, sube una imagen primero.",
                autoSolveConfirm: "¿Quieres que el rompecabezas se resuelva automáticamente? Esto reiniciará tus movimientos.",
                autoSolveWarning5x5: "Advertencia: ¡La resolución automática 5x5 es muy lenta! Ten paciencia.",
                autoSolveWarning6x6: "Advertencia: ¡La resolución automática 6x6 es extremadamente lenta! Ten paciencia.",
                autoSolveWarning7x7: "Advertencia: ¡La resolución automática 7x7 es imprácticamente lenta! Úsala con precaución.",
                autoSolveSearching: "Buscando solución automática...",
                solutionFound: (numMoves) => `¡Solución encontrada! Reproduciendo ${numMoves} movimientos...`,
                errorPlayingSolution: "Ocurrió un error al reproducir la solución.",
                solutionNotFound: "Solución no encontrada dentro de los límites de tiempo/cálculo. Intenta barajar de nuevo.",
                noReplayMoves: "No hay movimientos para reproducir.",
                replayFinished: "Reproducción finalizada.",
                puzzleSolved: (moves, time) => `¡Felicidades! Rompecabezas resuelto en ${moves} movimientos y ${time}!`,
                cropCancelled: "Recorte cancelado. Por favor, sube o selecciona otra imagen.",
                noImageLoaded: "No hay imagen cargada para mostrar.",
                pieceMoved: (pieceNumber, direction) => `Pieza ${pieceNumber} movida ${direction}`,
                directionRight: "Derecha",
                directionLeft: "Izquierda",
                directionDown: "Abajo",
                directionUp: "Arriba",
                playerStatsTitle: "Estadísticas del Jugador:",
                totalGamesPlayed: "Total de Juegos Jugados",
                totalTimePlayed: "Tiempo Total Jugado",
                bestTime3x3: "Mejor Tiempo (3x3)",
                bestMoves3x3: "Mejores Movimientos (3x3)",
                movesPerTimeGraphTitle: "Movimientos por Intervalo de Tiempo:", // New
                notApplicable: "--",
                puzzleNotShuffled: "El rompecabezas aún no está barajado. Haz clic en 'Barajar' para empezar.",
            },
            ja: {
                mainTitle: "インタラクティブスライディングパズル",
                selectLanguage: "言語を選択:",
                selectTheme: "テーマを選択:",
                lightTheme: "ライト",
                darkTheme: "ダーク",
                uploadPhoto: "写真をアップロード:",
                orSelectSample: "またはサンプル画像を選択:",
                selectPuzzleSize: "パズルサイズを選択:",
                selectPuzzleMode: "パズルモードを選択:",
                shuffleStrength: "シャッフル強度（移動回数）:",
                shuffleStrengthHint: "パズルをシャッフルするランダムな移動の数。",
                numberColor: "数字の色:", // New
                numberColorHint: "パズルピースの数字の色を選択します。", // New
                slidingPuzzle: "スライディングパズル（デフォルト）",
                jigsaw: "ジグソー（数字なし）",
                moves: "移動",
                time: "時間",
                shuffle: "シャッフル",
                undo: "元に戻す",
                autoSolve: "自動解決",
                resetPuzzle: "パズルをリセット",
                viewOriginalImage: "元の画像を見る",
                replayMoves: "動きを再生",
                clickHint: "空のスペースに隣接するピースをクリックして移動します。",
                moveHistoryTitle: "あなたの移動履歴:",
                noMovesYet: "まだ動きはありません。",
                backToPuzzle: "パズルに戻る",
                cropAreaTitle: "パズル領域を選択",
                confirmCrop: "トリミングを確定",
                cancel: "キャンセル",
                loading: "読み込み中...",
                loadingImage: "画像を読み込み中...",
                loadingSampleImage: "サンプル画像を読み込み中...",
                failedLoadImage: "画像の読み込みに失敗しました。有効な画像ファイルであることを確認してください。",
                failedLoadSampleImage: "サンプル画像の読み込みに失敗しました。もう一度試すか、ご自身の画像をアップロードしてください。",
                shufflingPuzzle: "パズルをシャッフル中...",
                shuffleFail: (attempts) => `${attempts}回の試行後も解けるパズルが見つかりませんでした。もう一度シャッフルしてみてください。`,
                noUndo: "元に戻す動きはありません。",
                confirmReset: "パズルをリセットしてもよろしいですか？進行状況は失われます。",
                uploadImageFirst: "まず画像をアップロードしてください。",
                autoSolveConfirm: "パズルを自動的に解決しますか？これにより、あなたの移動がリセットされます。",
                autoSolveWarning5x5: "警告：5x5の自動解決は非常に遅いです！しばらくお待ちください。",
                autoSolveWarning6x6: "警告：6x6の自動解決は非常に遅いです！しばらくお待ちください。",
                autoSolveWarning7x7: "警告：7x7の自動解決は実用的に遅いです！注意して使用してください。",
                autoSolveSearching: "自動解決策を検索中...",
                solutionFound: (numMoves) => `解決策が見つかりました！${numMoves}回の移動を再生中...`,
                errorPlayingSolution: "解決策の再生中にエラーが発生しました。",
                solutionNotFound: "時間/計算制限内で解決策が見つかりませんでした。もう一度シャッフルしてください。",
                noReplayMoves: "再生する動きはありません。",
                replayFinished: "再生が終了しました。",
                puzzleSolved: (moves, time) => `おめでとうございます！${moves}回の移動と${time}でパズルが解決しました！`,
                cropCancelled: "トリミングがキャンセルされました。別の画像をアップロードまたは選択してください。",
                noImageLoaded: "表示する画像が読み込まれていません。",
                pieceMoved: (pieceNumber, direction) => `ピース${pieceNumber}が${direction}に移動しました`,
                directionRight: "右",
                directionLeft: "左",
                directionDown: "下",
                directionUp: "上",
                playerStatsTitle: "プレイヤー統計:",
                totalGamesPlayed: "総プレイ回数",
                totalTimePlayed: "総プレイ時間",
                bestTime3x3: "ベストタイム (3x3)",
                bestMoves3x3: "ベストムーブ (3x3)",
                movesPerTimeGraphTitle: "時間間隔あたりの移動数:", // New
                notApplicable: "--",
                puzzleNotShuffled: "パズルはまだシャッフルされていません。開始するには「シャッフル」をクリックしてください。",
            }
        };

        // =====================================================================
        // Function to update all text content based on current language
        // =====================================================================
        function updateTextContent() {
            const elements = document.querySelectorAll('[data-key]');
            elements.forEach(element => {
                const key = element.getAttribute('data-key');
                if (translations[currentLanguage][key]) {
                    if (typeof translations[currentLanguage][key] === 'function') {
                        element.textContent = translations[currentLanguage][key].name ? key : translations[currentLanguage][key];
                    } else {
                        element.textContent = translations[currentLanguage][key];
                    }
                }
            });

            document.getElementById('puzzleModeSelect').querySelector('option[value="sliding"]').textContent = translations[currentLanguage].slidingPuzzle;
            document.getElementById('puzzleModeSelect').querySelector('option[value="jigsaw"]').textContent = translations[currentLanguage].jigsaw;
            
            document.getElementById('themeSelect').querySelector('option[value="light"]').textContent = translations[currentLanguage].lightTheme;
            document.getElementById('themeSelect').querySelector('option[value="dark"]').textContent = translations[currentLanguage].darkTheme;

            const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
            const placeholderSize = fixedCanvasSize;
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            
            renderMoveHistory();
            updatePlayerStatisticsDisplay();
            drawMovesPerTimeGraph(); // Update graph on language change
        }

        // =====================================================================
        // Handle Language Selection Change (with Local Storage)
        // =====================================================================
        languageSelect.addEventListener('change', (event) => {
            currentLanguage = event.target.value;
            savePreferences();
            updateTextContent();
        });

        // =====================================================================
        // Handle Theme Selection Change (with Local Storage)
        // =====================================================================
        themeSelect.addEventListener('change', (event) => {
            currentTheme = event.target.value;
            applyTheme(currentTheme);
            savePreferences();
            if (puzzleReady) {
                drawPuzzle();
            }
            drawMovesPerTimeGraph(); // Update graph on theme change
        });

        // =====================================================================
        // Handle Number Color Picker Change (with Local Storage)
        // =====================================================================
        numberColorPicker.addEventListener('input', (event) => {
            numberColor = event.target.value;
            savePreferences();
            if (puzzleReady) {
                drawPuzzle(); // Redraw puzzle with new number color
            }
        });

        // =====================================================================
        // Utility function for notifications (replaces alert())
        // =====================================================================
        function showMessageBox(messageKey, ...args) {
            const message = typeof translations[currentLanguage][messageKey] === 'function' 
                            ? translations[currentLanguage][messageKey](...args) 
                            : translations[currentLanguage][messageKey];

            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Custom Confirmation Box
        // =====================================================================
        function showConfirmationBox(messageKey, onConfirmCallback) {
            const message = translations[currentLanguage][messageKey];
            const confirmationBox = document.createElement('div');
            confirmationBox.className = 'confirmation-box';
            confirmationBox.innerHTML = `
                <p class="text-xl font-semibold mb-6">${message}</p>
                <div class="flex justify-center gap-4">
                    <button id="confirmButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-md transition duration-300">${translations[currentLanguage].confirmCrop}</button>
                    <button id="cancelButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-md transition duration-300">${translations[currentLanguage].cancel}</button>
                </div>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            confirmationBoxContainer.appendChild(overlay);
            confirmationBoxContainer.appendChild(confirmationBox);

            document.getElementById('confirmButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
                onConfirmCallback();
            };
            document.getElementById('cancelButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Loading Indicator Functions
        // =====================================================================
        function showLoading(messageKey) {
            loadingMessage.textContent = translations[currentLanguage][messageKey];
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // =====================================================================
        // Function to check puzzle solvability
        // =====================================================================
        function isPuzzleSolvable(piecesArray, currentGridSize) {
            const currentOrder = Array(currentGridSize * currentGridSize).fill(0);
            const piecePositions = new Map();
            
            piecesArray.forEach(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                const index = row * currentGridSize + col;
                currentOrder[index] = p.id;
                piecePositions.set(p.id, index);
            });
            const blankPiece = piecesArray.find(p => p.isBlank);
            const blankIndex = piecePositions.get(blankPiece.id);
            const blankRowFromTop = Math.floor(blankIndex / currentGridSize);
            const flatState = currentOrder.filter(id => id !== blankPiece.id);
            let inversions = 0;
            for (let i = 0; i < flatState.length - 1; i++) {
                for (let j = i + 1; j < flatState.length; j++) {
                    if (flatState[i] > flatState[j]) {
                        inversions++;
                    }
                }
            }

            if (currentGridSize % 2 === 1) {
                return inversions % 2 === 0;
            } else {
                const blankRowFromBottom = currentGridSize - blankRowFromTop;
                if (blankRowFromBottom % 2 === 1) {
                    return inversions % 2 === 0;
                } else {
                    return inversions % 2 === 1;
                }
            }
        }


        // =====================================================================
        // Handle Image Upload
        // =====================================================================
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                showLoading("loadingImage");
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage.onload = async () => {
                        hideLoading();
                        if (originalImage.width === originalImage.height) {
                            initializePuzzle(0, 0, originalImage.width, originalImage.height);
                            await animateShuffle();
                        } else {
                            setupCroppingInterface();
                        }
                    };
                    originalImage.onerror = () => {
                        hideLoading();
                        showMessageBox("failedLoadImage");
                        enableAllButtons();
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        // =====================================================================
        // Handle Sample Image Selection
        // =====================================================================
        sampleImageContainers.forEach(container => {
            container.addEventListener('click', async (event) => {
                const imageUrl = container.dataset.src;
                if (!imageUrl) return;

                if (shuffling || solving || isProcessingClick || isReplaying) return;

                showLoading("loadingSampleImage");
                disableAllButtons();

                originalImage.onload = async () => {
                    hideLoading();
                    if (originalImage.width === originalImage.height) {
                        initializePuzzle(0, 0, originalImage.width, originalImage.height);
                        await animateShuffle();
                    } else {
                        setupCroppingInterface();
                    }
                };
                originalImage.onerror = () => {
                    hideLoading();
                    showMessageBox("failedLoadSampleImage");
                    enableAllButtons();
                };
                originalImage.src = imageUrl;
            });
        });


        // =====================================================================
        // Handle Grid Size and Puzzle Mode Changes (with Local Storage)
        // =====================================================================
        gridSizeSelect.addEventListener('change', async (event) => {
            gridSize = parseInt(event.target.value);
            savePreferences();
            if (puzzleReady) {
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            }
        });

        puzzleModeSelect.addEventListener('change', async (event) => {
            currentPuzzleMode = event.target.value;
            savePreferences();
            if (puzzleReady) {
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                drawPuzzle();
            }
        });

        // =====================================================================
        // Handle Shuffle Strength Input Change (with Local Storage)
        // =====================================================================
        shuffleStrengthInput.addEventListener('change', (event) => {
            let value = parseInt(event.target.value);
            if (isNaN(value) || value < 10) {
                value = 10;
            } else if (value > 1000) {
                value = 1000;
            }
            shuffleStrength = value;
            event.target.value = value;
            savePreferences();
        });

        // =====================================================================
        // Initialize Puzzle (Adapts image to 1:1, sets up pieces)
        // =====================================================================
        function initializePuzzle(srcX, srcY, srcW, srcH) {
            finalSourceX = srcX;
            finalSourceY = srcY;
            finalSourceWidth = srcW;
            finalSourceHeight = srcH;

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;
            confettiCanvas.width = fixedCanvasSize;
            confettiCanvas.height = fixedCanvasSize;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            puzzlePieces = [];
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < totalPieces; i++) {
                puzzlePieces.push({
                    id: i,
                    originalIndex: i,
                    currentX: (i % gridSize) * pieceWidth,
                    currentY: Math.floor(i / gridSize) * pieceHeight,
                    sourceX: srcX + (srcW / gridSize) * (i % gridSize),
                    sourceY: srcY + (srcH / gridSize) * Math.floor(i / gridSize),
                    sourceWidth: srcW / gridSize,
                    sourceHeight: srcH / gridSize,
                    isBlank: false
                });
            }
            blankPieceIndex = totalPieces - 1;
            puzzlePieces[blankPieceIndex].isBlank = true;
            isShuffled = false;
            moves = 0;
            undoStack = [];
            replayMoves = [];
            initialShuffledStateForReplay = [];
            replayButton.style.display = 'none';
            moveHistory = [];
            movesPerIntervalData = []; // Reset moves per interval data
            lastRecordedTotalMoves = 0; // Reset for new game
            lastGraphUpdateTime = 0; // Reset for new game
            renderMoveHistory();
            updateMoveCounter();
            stopTimer();
            timerDisplay.textContent = '00:00';
            hasMadeFirstMove = false;
            drawPuzzle();
            updateProgressIndicator();
            hoveredPieceIndex = -1;

            puzzleCanvas.classList.remove('puzzle-solved-animation');
            solveStatusDisplay.textContent = '';
            puzzleReady = true;
            enableAllButtons();
            stopConfetti();

            updatePlayerStatisticsDisplay(); // No Manhattan stats to reset here

            currentBase64Image = puzzleCanvas.toDataURL('image/png');
            drawMovesPerTimeGraph(); // Initialize graph
        }

        // =====================================================================
        // Recalculate piece positions and redraw (used for resize without resetting state)
        // =====================================================================
        function recalculatePiecePositionsAndRedraw() {
            if (!puzzleReady) return;

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;
            confettiCanvas.width = fixedCanvasSize;
            confettiCanvas.height = fixedCanvasSize;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });

            drawPuzzle();
            updateProgressIndicator();
            drawMovesPerTimeGraph(); // Redraw graph on resize
        }

        // =====================================================================
        // Draw Puzzle on Canvas
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
            puzzlePieces.forEach(piece => {
                if (!piece.isBlank) {
                    ctx.drawImage(
                        originalImage,
                        piece.sourceX, piece.sourceY,
                        piece.sourceWidth, piece.sourceHeight,
                        piece.currentX, piece.currentY,
                        pieceWidth, pieceHeight
                    );

                    const borderColor = currentTheme === 'dark' ? '#4f46e5' : '#6366f1';
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);

                    if (currentPuzzleMode === 'sliding') {
                        const fontSize = Math.min(pieceWidth, pieceHeight) * 0.3;
                        ctx.font = `${fontSize}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        ctx.fillStyle = numberColor; // Use selected number color
                        ctx.fillText(
                            piece.id + 1,
                            piece.currentX + pieceWidth / 2,
                            piece.currentY + pieceHeight / 2
                        );
                    }
                } else {
                    const blankBgColor = currentTheme === 'dark' ? '#4a5568' : '#e0e7ff';
                    const blankBorderColor = currentTheme === 'dark' ? '#4f46e5' : '#6366f1';
                    ctx.fillStyle = blankBgColor;
                    ctx.fillRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    ctx.strokeStyle = blankBorderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                }
            });

            if (hoveredPieceIndex !== -1 && !isProcessingClick && !solving && !shuffling && !isReplaying) {
                const hoveredPiece = puzzlePieces.find(p => p.id === hoveredPieceIndex);
                if (hoveredPiece && !hoveredPiece.isBlank) {
                    const blankPiece = puzzlePieces.find(p => p.isBlank);
                    const hoveredPieceCol = Math.round(hoveredPiece.currentX / pieceWidth);
                    const hoveredPieceRow = Math.round(hoveredPiece.currentY / pieceHeight);
                    const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
                    const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

                    const isAdjacent = (
                        (Math.abs(hoveredPieceCol - blankPieceCol) === 1 && hoveredPieceRow === blankPieceRow) ||
                        (Math.abs(hoveredPieceRow - blankPieceRow) === 1 && hoveredPieceCol === blankPieceCol)
                    );

                    if (isAdjacent) {
                        ctx.strokeStyle = currentTheme === 'dark' ? '#9370DB' : '#a855f7';
                        ctx.lineWidth = 4;
                        ctx.shadowColor = currentTheme === 'dark' ? 'rgba(147, 112, 219, 0.7)' : 'rgba(168, 85, 247, 0.7)';
                        ctx.shadowBlur = 10;
                        ctx.strokeRect(hoveredPiece.currentX, hoveredPiece.currentY, pieceWidth, pieceHeight);
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }

        // =====================================================================
        // Shuffle Puzzle with visual animation and ensure solvability
        // =====================================================================
        async function animateShuffle() {
            if (!puzzleReady || shuffling || solving || isReplaying) {
                return;
            }
            shuffling = true;
            showLoading("shufflingPuzzle");
            disableAllButtons();
            solveStatusDisplay.textContent = translations[currentLanguage].shufflingPuzzle;
            const originalBlankId = gridSize * gridSize - 1;
            
            const numMoves = shuffleStrength;
            const visualDelay = 10;

            let currentSolvable = false;
            let shuffleAttempts = 0;
            const maxShuffleAttempts = 10;

            let finalPuzzleOrder = null;

            while (!currentSolvable && shuffleAttempts < maxShuffleAttempts) {
                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                    piece.isBlank = (piece.id === originalBlankId);
                });
                drawPuzzle();

                let currentVisualPieces = puzzlePieces.map(p => ({ ...p }));
                let currentVisualBlankPiece = currentVisualPieces.find(p => p.isBlank);
                for (let i = 0; i < numMoves; i++) {
                    if (!shuffling) {
                        break;
                    }

                    const blankCol = Math.round(currentVisualBlankPiece.currentX / pieceWidth);
                    const blankRow = Math.round(currentVisualBlankPiece.currentY / pieceHeight);

                    const possibleMoves = [];
                    if (blankRow > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow - 1));
                    if (blankRow < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow + 1));
                    if (blankCol > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol - 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    if (blankCol < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol + 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    const validMoves = possibleMoves.filter(p => p && !p.isBlank);

                    if (validMoves.length === 0) continue;

                    const pieceToMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    const tempX = pieceToMove.currentX;
                    const tempY = pieceToMove.currentY;

                    pieceToMove.currentX = currentVisualBlankPiece.currentX;
                    pieceToMove.currentY = currentVisualBlankPiece.currentY;

                    currentVisualBlankPiece.currentX = tempX;
                    currentVisualBlankPiece.currentY = tempY;
                    const pieceToMoveIndexInArray = currentVisualPieces.indexOf(pieceToMove);
                    const blankIndexInArray = currentVisualPieces.indexOf(currentVisualBlankPiece);
                    [currentVisualPieces[pieceToMoveIndexInArray], currentVisualPieces[blankIndexInArray]] = 
                    [currentVisualPieces[blankIndexInArray], currentVisualPieces[pieceToMoveIndexInArray]];
                    puzzlePieces = currentVisualPieces;
                    drawPuzzle();
                    await new Promise(resolve => setTimeout(resolve, visualDelay));
                }

                if (isPuzzleSolvable(puzzlePieces, gridSize)) {
                    currentSolvable = true;
                    finalPuzzleOrder = puzzlePieces.map(p => p.id);
                } else {
                    shuffleAttempts++;
                    console.warn(`Attempt ${shuffleAttempts}: Shuffled puzzle is not solvable. Retrying...`);
                }
            }

            hideLoading();

            if (!shuffling) {
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                enableAllButtons();
                return;
            }

            if (currentSolvable && finalPuzzleOrder) {
                let correctedPuzzlePieces = [];
                for (let i = 0; i < finalPuzzleOrder.length; i++) {
                    const pieceId = finalPuzzleOrder[i];
                    const originalPieceData = puzzlePieces.find(p => p.id === pieceId);
                    correctedPuzzlePieces.push({
                        ...originalPieceData,
                        currentX: (i % gridSize) * pieceWidth,
                        currentY: Math.floor(i / gridSize) * pieceHeight,
                        isBlank: (pieceId === originalBlankId)
                    });
                }
                puzzlePieces = correctedPuzzlePieces;
                drawPuzzle();

                isShuffled = true;
                moves = 0;
                undoStack = [];
                replayMoves = [];
                initialShuffledStateForReplay = puzzlePieces.map(p => ({ ...p }));
                replayButton.style.display = 'none';
                moveHistory = [];
                movesPerIntervalData = []; // Reset moves per interval data
                lastRecordedTotalMoves = 0; // Reset for new game
                lastGraphUpdateTime = 0; // Reset for new game
                renderMoveHistory();
                updateMoveCounter();
                hasMadeFirstMove = false;
                updateProgressIndicator();
                hoveredPieceIndex = -1;
                
                shuffling = false;
                enableAllButtons();

                solveStatusDisplay.textContent = '';
                drawMovesPerTimeGraph(); // Update graph after shuffle
            } else {
                shuffling = false;
                enableAllButtons();
                solveStatusDisplay.textContent = translations[currentLanguage].shuffleFail(maxShuffleAttempts);
                showMessageBox("shuffleFail", maxShuffleAttempts);
                if (finalSourceWidth > 0 && finalSourceHeight > 0) {
                    initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                } else {
                    const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                    const placeholderSize = fixedCanvasSize;
                    originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
                }
            }
        }


        shuffleButton.addEventListener('click', animateShuffle);
        // =====================================================================
        // Undo Puzzle Move
        // =====================================================================
        undoButton.addEventListener('click', () => {
            if (isProcessingClick || solving || shuffling || isReplaying) return;

            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                puzzlePieces = prevState.pieces.map(p => ({ ...p }));
                moves = prevState.moves;
                isShuffled = prevState.isShuffled;
                currentPuzzleMode = prevState.puzzleMode;

                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                });

                if (replayMoves.length > 0) {
                    replayMoves.pop();
                }
                moveHistory.shift();
                renderMoveHistory();

                updateMoveCounter();
                drawPuzzle();
                updateProgressIndicator();
                puzzleModeSelect.value = currentPuzzleMode;
                hoveredPieceIndex = -1;
                // Re-calculate lastRecordedTotalMoves for graph if undoing past a graph point
                if (movesPerIntervalData.length > 0) {
                    const lastDataPoint = movesPerIntervalData[movesPerIntervalData.length - 1];
                    if (moves < lastDataPoint.totalMovesAtTime) { // If undoing past a recorded point
                        movesPerIntervalData.pop(); // Remove the last point
                        if (movesPerIntervalData.length > 0) {
                            lastRecordedTotalMoves = movesPerIntervalData[movesPerIntervalData.length - 1].totalMovesAtTime;
                            lastGraphUpdateTime = movesPerIntervalData[movesPerIntervalData.length - 1].time;
                        } else {
                            lastRecordedTotalMoves = 0;
                            lastGraphUpdateTime = 0;
                        }
                    }
                }
                drawMovesPerTimeGraph(); // Update graph after undo
            } else {
                showMessageBox("noUndo");
            }
        });

        // =====================================================================
        // Reset Puzzle to Original Order
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (isReplaying) return;

            showConfirmationBox("confirmReset", () => {
                if (!puzzleReady) {
                    showMessageBox("uploadImageFirst");
                    return;
                }

                solving = false;
                shuffling = false;

                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);

                puzzlePieces.forEach((piece, index) => {
                    const targetCol = index % gridSize;
                    const targetRow = Math.floor(index / gridSize);
                    piece.currentX = targetCol * pieceWidth;
                    piece.currentY = targetRow * pieceHeight;
                });

                isShuffled = false;
                moves = 0;
                undoStack = [];
                replayMoves = [];
                initialShuffledStateForReplay = [];
                replayButton.style.display = 'none';
                moveHistory = [];
                movesPerIntervalData = []; // Reset moves per interval data
                lastRecordedTotalMoves = 0; // Reset for new game
                lastGraphUpdateTime = 0; // Reset for new game
                renderMoveHistory();
                updateMoveCounter();
                stopTimer();
                timerDisplay.textContent = '00:00';
                hasMadeFirstMove = false;
                drawPuzzle();
                updateProgressIndicator();
                puzzleCanvas.classList.remove('puzzle-solved-animation');
                solveStatusDisplay.textContent = '';
                stopConfetti();
                hoveredPieceIndex = -1;

                updatePlayerStatisticsDisplay(); // No Manhattan stats to reset here
                drawMovesPerTimeGraph(); // Reset graph on reset

                enableAllButtons();
            });
        });


        // =====================================================================
        // Handle Puzzle Click/Touch (to move pieces)
        // =====================================================================
        puzzleCanvas.addEventListener('click', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling || isReplaying) {
                if (puzzleReady && !isShuffled) {
                    showMessageBox("puzzleNotShuffled");
                }
                return;
            }
            isProcessingClick = true;

            if (!hasMadeFirstMove) {
                hasMadeFirstMove = true;
                startTimer();
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const clickedCol = Math.floor(mouseX / pieceWidth);
            const clickedRow = Math.floor(mouseY / pieceHeight);
            
            const clickedPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (clickedCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (clickedRow * pieceHeight)) < 1
            );
            if (!clickedPiece || clickedPiece.isBlank) {
                isProcessingClick = false;
                return;
            }

            const blankPiece = puzzlePieces.find(p => p.isBlank);
            const clickedPieceCol = Math.round(clickedPiece.currentX / pieceWidth);
            const clickedPieceRow = Math.round(clickedPiece.currentY / pieceHeight);
            const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
            const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

            const isAdjacent = (
                (Math.abs(clickedPieceCol - blankPieceCol) === 1 && clickedPieceRow === blankPieceRow) ||
                (Math.abs(clickedPieceRow - blankPieceRow) === 1 && clickedPieceCol === blankPieceCol)
            );
            if (isAdjacent) {
                const currentStatePieces = puzzlePieces.map(p => ({ ...p }));
                undoStack.push({ pieces: currentStatePieces, moves: moves, isShuffled: isShuffled, puzzleMode: currentPuzzleMode });
                if (undoStack.length > maxUndoStates) {
                    undoStack.shift();
                }

                const targetXForClicked = blankPiece.currentX;
                const targetYForClicked = blankPiece.currentY;
                const targetXForBlank = clickedPiece.currentX;
                const targetYForBlank = clickedPiece.currentY;

                const fromIndex = clickedPieceRow * gridSize + clickedCol;
                const toIndex = blankPieceRow * gridSize + blankPieceCol;
                replayMoves.push({ pieceId: clickedPiece.id, fromIndex: fromIndex, toIndex: toIndex });
                
                animatePieceMove(
                    clickedPiece, targetXForClicked, targetYForClicked,
                    blankPiece, targetXForBlank, targetYForBlank,
                    () => {
                        clickedPiece.currentX = targetXForClicked;
                        clickedPiece.currentY = targetYForClicked;
                        blankPiece.currentX = targetXForBlank;
                        blankPiece.currentY = targetYForBlank;

                        const clickedIndexInArray = puzzlePieces.indexOf(clickedPiece);
                        const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                        [puzzlePieces[clickedIndexInArray], puzzlePieces[blankIndexInArray]] = 
                        [puzzlePieces[blankIndexInArray], puzzlePieces[clickedIndexInArray]];

                        moves++;
                        updateMoveCounter();
                        drawPuzzle();
                        updateProgressIndicator();

                        addMoveToHistory(clickedPiece.id + 1, fromIndex, toIndex, gridSize); // Add to move history
                        // Graph update is now handled by the timer

                        checkWin();
                        isProcessingClick = false;
                    }
                );
            } else {
                isProcessingClick = false;
            }
        });

        // =====================================================================
        // Handle mouse/touch events for hover effect
        // =====================================================================
        puzzleCanvas.addEventListener('mousemove', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling || isReplaying) {
                if (hoveredPieceIndex !== -1) {
                    hoveredPieceIndex = -1;
                    drawPuzzle();
                }
                return;
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const currentHoveredCol = Math.floor(mouseX / pieceWidth);
            const currentHoveredRow = Math.floor(mouseY / pieceHeight);
            
            const currentHoveredPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (currentHoveredCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (currentHoveredRow * pieceHeight)) < 1
            );

            let newHoveredIndex = -1;
            if (currentHoveredPiece && !currentHoveredPiece.isBlank) {
                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const hoveredPieceCol = Math.round(currentHoveredPiece.currentX / pieceWidth);
                const hoveredPieceRow = Math.round(currentHoveredPiece.currentY / pieceHeight);
                const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
                const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

                const isAdjacent = (
                    (Math.abs(hoveredPieceCol - blankPieceCol) === 1 && hoveredPieceRow === blankPieceRow) ||
                    (Math.abs(hoveredPieceRow - blankPieceRow) === 1 && hoveredPieceCol === blankPieceCol)
                );
                if (isAdjacent) {
                    newHoveredIndex = currentHoveredPiece.id;
                }
            }

            if (newHoveredIndex !== hoveredPieceIndex) {
                hoveredPieceIndex = newHoveredIndex;
                drawPuzzle();
            }
        });

        puzzleCanvas.addEventListener('mouseout', () => {
            if (hoveredPieceIndex !== -1) {
                hoveredPieceIndex = -1;
                drawPuzzle();
            }
        });

        // =====================================================================
        // Piece Movement Animation Function (for manual & auto-solve moves)
        // =====================================================================
        function animatePieceMove(piece1, targetX1, targetY1, piece2, targetX2, targetY2, callback) {
            const startX1 = piece1.currentX;
            const startY1 = piece1.currentY;
            const startX2 = piece2.currentX;
            const startY2 = piece2.currentY;

            let startTime = null;
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                piece1.currentX = startX1 + (targetX1 - startX1) * progress;
                piece1.currentY = startY1 + (targetY1 - startY1) * progress;
                piece2.currentX = startX2 + (targetX2 - startX2) * progress;
                piece2.currentY = startY2 + (targetY2 - startY2) * progress;
                
                drawPuzzle();
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback();
                }
            }
            requestAnimationFrame(animate);
        }

        // =====================================================================
        // Update Move Counter
        // =====================================================================
        function updateMoveCounter() {
            moveCounterDisplay.textContent = moves;
        }

        // =====================================================================
        // Timer Functions
        // =====================================================================
        function startTimer() {
            stopTimer();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');

            timerDisplay.textContent = `${formattedMinutes}:${formattedSeconds}`;

            // Update moves per time graph data
            if (totalSeconds >= lastGraphUpdateTime + graphUpdateInterval || (totalSeconds === 0 && moves > 0 && movesPerIntervalData.length === 0)) {
                const movesInInterval = moves - lastRecordedTotalMoves;
                movesPerIntervalData.push({ time: totalSeconds, moves: movesInInterval, totalMovesAtTime: moves });
                lastRecordedTotalMoves = moves;
                lastGraphUpdateTime = totalSeconds;
                drawMovesPerTimeGraph();
            }
        }

        // =====================================================================
        // Check Win Condition & Display Win Animation
        // =====================================================================
        function checkWin() {
            if (!isShuffled) return;
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id !== currentPieceIndex) {
                    solved = false;
                    break;
                }
            }

            if (solved) {
                isShuffled = false;
                stopTimer();
                hasMadeFirstMove = false;

                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const blankPieceCurrentIndexInArray = puzzlePieces.indexOf(blankPiece);
                const lastCorrectArrayPosition = puzzlePieces.length - 1;
                if (blankPieceCurrentIndexInArray !== lastCorrectArrayPosition) {
                    const pieceAtLastPosition = puzzlePieces[lastCorrectArrayPosition];
                    puzzlePieces[lastCorrectArrayPosition] = blankPiece;
                    puzzlePieces[blankPieceCurrentIndexInArray] = pieceAtLastPosition;

                    blankPiece.currentX = (lastCorrectArrayPosition % gridSize) * pieceWidth;
                    blankPiece.currentY = Math.floor(lastCorrectArrayPosition / gridSize) * pieceHeight;
                    pieceAtLastPosition.currentX = (blankPieceCurrentIndexInArray % gridSize) * pieceWidth;
                    pieceAtLastPosition.currentY = Math.floor(blankPieceCurrentIndexInArray / gridSize) * pieceHeight;
                }
                
                drawPuzzle();
                puzzleCanvas.classList.add('puzzle-solved-animation');
                startConfetti();
                
                showMessageBox("puzzleSolved", moves, timerDisplay.textContent);
                
                enableAllButtons();
                solving = false;
                shuffling = false;
                isProcessingClick = false;
                hoveredPieceIndex = -1;

                if (replayMoves.length > 0) {
                    replayButton.style.display = 'inline-block';
                }

                updatePlayerStatistics(moves, Math.floor((Date.now() - startTime) / 1000));
                updateProgressIndicator();
                // No Manhattan analysis here anymore
            }
        }

        // =====================================================================
        // Disable all interactive buttons
        // =====================================================================
        function disableAllButtons() {
            shuffleButton.disabled = true;
            undoButton.disabled = true;
            solveButton.disabled = true;
            resetButton.disabled = false;
            imageUpload.disabled = true;
            gridSizeSelect.disabled = true;
            puzzleModeSelect.disabled = true;
            shuffleStrengthInput.disabled = true;
            numberColorPicker.disabled = true; // Disable color picker
            viewOriginalImageButton.disabled = true;
            replayButton.disabled = true;
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'none');
            sampleImageContainers.forEach(container => container.style.opacity = '0.5');
            languageSelect.disabled = true;
            themeSelect.disabled = true;
        }

        // =====================================================================
        // Enable all interactive buttons
        // =====================================================================
        function enableAllButtons() {
            shuffleButton.disabled = false;
            undoButton.disabled = false;
            solveButton.disabled = false; 
            resetButton.disabled = false;
            imageUpload.disabled = false;
            gridSizeSelect.disabled = false;
            puzzleModeSelect.disabled = false;
            shuffleStrengthInput.disabled = false;
            numberColorPicker.disabled = false; // Enable color picker
            viewOriginalImageButton.disabled = false;
            replayButton.disabled = false;
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'auto');
            sampleImageContainers.forEach(container => container.style.opacity = '1');
            languageSelect.disabled = false;
            themeSelect.disabled = false;
        }

        // =====================================================================
        // Function to auto-solve puzzle using BFS (Breadth-First Search)
        // =====================================================================
        solveButton.addEventListener('click', () => {
            showConfirmationBox("autoSolveConfirm", async () => {
                await solvePuzzleAutomatically();
            });
        });

        async function solvePuzzleAutomatically() {
            if (!puzzleReady || !isShuffled || solving || shuffling || isProcessingClick) {
                return;
            }

            solving = true;
            isProcessingClick = true;
            hasMadeFirstMove = true;
            startTimer();
            if (gridSize === 7) {
                showLoading("autoSolveWarning7x7");
            } else if (gridSize === 6) {
                showLoading("autoSolveWarning6x6");
            } else if (gridSize === 5) {
                showLoading("autoSolveWarning5x5");
            } else {
                showLoading("autoSolveSearching");
            }
            
            disableAllButtons();
            resetButton.disabled = false;

            stopTimer();

            const queue = [];
            const visited = new Set();

            const initialPiecesState = puzzlePieces.map(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                return { id: p.id, currentPos: row * gridSize + col };
            });
            initialPiecesState.sort((a, b) => a.currentPos - b.currentPos);

            const initialOrderedIds = initialPiecesState.map(p => p.id);
            const blankId = puzzlePieces.find(p => p.isBlank).id;
            const initialBlankPos = initialOrderedIds.indexOf(blankId);

            queue.push({ state: initialOrderedIds, path: [], blankPos: initialBlankPos });
            visited.add(JSON.stringify(initialOrderedIds));
            let solutionPath = null;
            let count = 0; 

            while (queue.length > 0 && solving && count < maxStatesToExploreForBFS) {
                const { state, path, blankPos } = queue.shift();
                count++;

                const isSolved = state.every((id, index) => id === index);
                if (isSolved) {
                    solutionPath = path;
                    break;
                }

                const blankRow = Math.floor(blankPos / gridSize);
                const blankCol = blankPos % gridSize;

                const possibleSwapPositions = [];
                if (blankRow > 0) possibleSwapPositions.push(blankPos - gridSize);
                if (blankRow < gridSize - 1) possibleSwapPositions.push(blankPos + gridSize); 
                if (blankCol > 0) possibleSwapPositions.push(blankPos - 1);
                if (blankCol < gridSize - 1) possibleSwapPositions.push(blankPos + 1); 

                for (const pieceToSwapIndex of possibleSwapPositions) {
                    const nextState = [...state];
                    const tempId = nextState[blankPos];
                    nextState[blankPos] = nextState[pieceToSwapIndex];
                    nextState[pieceToSwapIndex] = tempId;

                    const nextStateStr = JSON.stringify(nextState);
                    if (!visited.has(nextStateStr)) {
                        visited.add(nextStateStr);
                        queue.push({
                            state: nextState,
                            path: [...path, state[pieceToSwapIndex]],
                            blankPos: pieceToSwapIndex 
                        });
                    }
                }
                if (count % 1000 === 0) { 
                    await new Promise(resolve => setTimeout(resolve, 0));
                    if (!solving) break; 
                }
            }

            hideLoading();

            if (!solving) {
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                enableAllButtons();
                return;
            }

            if (solutionPath) {
                solveStatusDisplay.textContent = translations[currentLanguage].solutionFound(solutionPath.length);
                const currentAutoSolveDelay = getAutoSolveStepDelay(gridSize);
                
                moves = 0;
                replayMoves = [];
                initialShuffledStateForReplay = [];
                replayButton.style.display = 'none';
                moveHistory = [];
                movesPerIntervalData = []; // Reset moves per interval data
                lastRecordedTotalMoves = 0; // Reset for new game
                lastGraphUpdateTime = 0; // Reset for new game
                renderMoveHistory();

                startTimer();
                for (const pieceIdToMove of solutionPath) {
                    if (!solving) break;

                    const pieceToMove = puzzlePieces.find(p => p.id === pieceIdToMove);
                    const blankPiece = puzzlePieces.find(p => p.isBlank);

                    if (!pieceToMove || !blankPiece) { 
                        console.error(translations[currentLanguage].errorPlayingSolution);
                        solving = false;
                        isProcessingClick = false;
                        enableAllButtons();
                        solveStatusDisplay.textContent = translations[currentLanguage].errorPlayingSolution;
                        stopTimer();
                        hasMadeFirstMove = false;
                        return;
                    }
                    
                    const startX1 = pieceToMove.currentX;
                    const startY1 = pieceToMove.currentY;
                    const startX2 = blankPiece.currentX;
                    const startY2 = blankPiece.currentY;

                    const targetX1 = startX2; 
                    const targetY1 = startY2;
                    const targetX2 = startX1; 
                    const targetY2 = startY1; 

                    await new Promise(resolve => {
                        animatePieceMove(
                            pieceToMove, targetX1, targetY1,
                            blankPiece, targetX2, targetY2,
                            () => {
                                pieceToMove.currentX = targetX1;
                                pieceToMove.currentY = targetY1;
                                blankPiece.currentX = targetX2;
                                blankPiece.currentY = targetY2;

                                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                                const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                                [puzzlePieces[pieceToMoveCurrentIndex], puzzlePieces[blankIndexInArray]] =
                                [puzzlePieces[blankIndexInArray], puzzlePieces[pieceToMoveCurrentIndex]];

                                moves++;
                                updateMoveCounter();
                                drawPuzzle();
                                updateProgressIndicator();
                                resolve();
                            }
                        );
                    });
                    if (solving) {
                        await new Promise(resolve => setTimeout(resolve, currentAutoSolveDelay));
                    }
                }
                if (solving) {
                    checkWin();
                }
            } else { 
                solveStatusDisplay.textContent = translations[currentLanguage].solutionNotFound;
                showMessageBox('solutionNotFound');
            }

            solving = false;
            isProcessingClick = false;
            enableAllButtons();
            if (isShuffled && !solving) {
                startTimer();
            } else if (!isShuffled && !solving) {
                stopTimer();
                hasMadeFirstMove = false;
            }
        }
        
        // =====================================================================
        // Replay Functionality
        // =====================================================================
        replayButton.addEventListener('click', async () => {
            if (replayMoves.length === 0 || solving || shuffling || isProcessingClick) {
                showMessageBox("noReplayMoves");
                return;
            }

            isReplaying = true;
            disableAllButtons();
            stopTimer();
            solveStatusDisplay.textContent = translations[currentLanguage].replayFinished;

            puzzlePieces = initialShuffledStateForReplay.map(p => ({ ...p }));
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });
            moves = 0;
            updateMoveCounter();
            drawPuzzle();
            updateProgressIndicator();
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            stopConfetti();
            hoveredPieceIndex = -1;
            moveHistory = [];
            movesPerIntervalData = []; // Clear moves per interval data for replay
            lastRecordedTotalMoves = 0;
            lastGraphUpdateTime = 0;
            renderMoveHistory();
            drawMovesPerTimeGraph();

            for (const move of replayMoves) {
                if (!isReplaying) break;

                const pieceToMove = puzzlePieces.find(p => p.id === move.pieceId);
                const blankPiece = puzzlePieces.find(p => p.isBlank);

                if (!pieceToMove || !blankPiece) {
                    console.error("Error during replay: Piece or blank not found.");
                    break;
                }

                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                const blankPieceCurrentIndex = puzzlePieces.indexOf(blankPiece);

                const targetXForMovedPiece = (move.toIndex % gridSize) * pieceWidth;
                const targetYForMovedPiece = Math.floor(move.toIndex / gridSize) * pieceHeight;
                const targetXForBlank = (move.fromIndex % gridSize) * pieceWidth;
                const targetYForBlank = Math.floor(move.fromIndex / gridSize) * pieceHeight;

                await new Promise(resolve => {
                    animatePieceMove(
                        pieceToMove, targetXForMovedPiece, targetYForMovedPiece,
                        blankPiece, targetXForBlank, targetYForBlank,
                        () => {
                            pieceToMove.currentX = targetXForMovedPiece;
                            pieceToMove.currentY = targetYForMovedPiece;
                            blankPiece.currentX = targetXForBlank;
                            blankPiece.currentY = targetYForBlank;

                            const newPieceToMoveIndex = puzzlePieces.indexOf(pieceToMove);
                            const newBlankPieceIndex = puzzlePieces.indexOf(blankPiece);
                            [puzzlePieces[newPieceToMoveIndex], puzzlePieces[newBlankPieceIndex]] =
                            [puzzlePieces[newBlankPieceIndex], puzzlePieces[newPieceToMoveIndex]];

                            moves++;
                            updateMoveCounter();
                            drawPuzzle();
                            updateProgressIndicator();
                            resolve();
                        }
                    );
                });
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            isReplaying = false;
            solveStatusDisplay.textContent = translations[currentLanguage].replayFinished;
            checkWin();
            enableAllButtons();
        });


        // =====================================================================
        // Handle Window Resize Responsiveness
        // =====================================================================
        window.addEventListener('resize', async () => {
            if (!puzzleReady) return;

            solving = false;
            isProcessingClick = false;
            isReplaying = false;
            
            enableAllButtons();
            solveStatusDisplay.textContent = '';
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            stopConfetti();
            hoveredPieceIndex = -1;

            recalculatePiecePositionsAndRedraw();
        });
        // =====================================================================
        // Local Storage Functions for Preferences and Player Stats
        // =====================================================================
        function savePreferences() {
            localStorage.setItem('puzzleGridSize', gridSizeSelect.value);
            localStorage.setItem('puzzleMode', puzzleModeSelect.value);
            localStorage.setItem('puzzleLanguage', currentLanguage);
            localStorage.setItem('puzzleTheme', currentTheme);
            localStorage.setItem('shuffleStrength', shuffleStrengthInput.value);
            localStorage.setItem('numberColor', numberColorPicker.value); // Save number color
        }

        function loadPreferences() {
            const savedGridSize = localStorage.getItem('puzzleGridSize');
            const savedPuzzleMode = localStorage.getItem('puzzleMode');
            const savedLanguage = localStorage.getItem('puzzleLanguage');
            const savedTheme = localStorage.getItem('puzzleTheme');
            const savedShuffleStrength = localStorage.getItem('shuffleStrength');
            const savedNumberColor = localStorage.getItem('numberColor'); // Load number color

            if (savedGridSize) {
                gridSizeSelect.value = savedGridSize;
                gridSize = parseInt(savedGridSize);
            }
            if (savedPuzzleMode) {
                puzzleModeSelect.value = savedPuzzleMode;
                currentPuzzleMode = savedPuzzleMode;
            }
            if (savedLanguage && translations[savedLanguage]) {
                currentLanguage = savedLanguage;
                languageSelect.value = savedLanguage;
            } else {
                currentLanguage = 'en';
                languageSelect.value = 'en';
            }
            if (savedTheme) {
                currentTheme = savedTheme;
                themeSelect.value = savedTheme;
            } else {
                currentTheme = 'light';
                themeSelect.value = 'light';
            }
            if (savedShuffleStrength) {
                shuffleStrengthInput.value = savedShuffleStrength;
                shuffleStrength = parseInt(savedShuffleStrength);
            } else {
                shuffleStrengthInput.value = 220;
                shuffleStrength = 220;
            }
            if (savedNumberColor) {
                numberColor = savedNumberColor;
                numberColorPicker.value = savedNumberColor;
            } else {
                numberColor = '#000000'; // Default black
                numberColorPicker.value = '#000000';
            }
            applyTheme(currentTheme);
        }

        function loadPlayerStatistics() {
            const savedStats = localStorage.getItem('playerStats');
            if (savedStats) {
                playerStats = JSON.parse(savedStats);
                if (playerStats.bestTime3x3Seconds === null || playerStats.bestTime3x3Seconds === 0) {
                    playerStats.bestTime3x3Seconds = Infinity;
                }
                if (playerStats.bestMoves3x3 === null || playerStats.bestMoves3x3 === 0) {
                    playerStats.bestMoves3x3 = Infinity;
                }
                // No Manhattan stats to load here
            }
        }

        function savePlayerStatistics() {
            localStorage.setItem('playerStats', JSON.stringify(playerStats));
        }

        function updatePlayerStatistics(currentMoves, currentTimeSeconds) {
            playerStats.totalGamesPlayed++;
            playerStats.totalTimePlayedSeconds += currentTimeSeconds;

            if (gridSize === 3) {
                if (currentTimeSeconds < playerStats.bestTime3x3Seconds) {
                    playerStats.bestTime3x3Seconds = currentTimeSeconds;
                }
                if (currentMoves < playerStats.bestMoves3x3) {
                    playerStats.bestMoves3x3 = currentMoves;
                }
            }
            savePlayerStatistics();
            updatePlayerStatisticsDisplay();
        }

        function formatTime(totalSeconds) {
            if (totalSeconds === Infinity) return translations[currentLanguage].notApplicable;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }

        function formatTimeShort(totalSeconds) {
            if (totalSeconds === Infinity) return translations[currentLanguage].notApplicable;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function updatePlayerStatisticsDisplay() {
            statTotalGames.textContent = playerStats.totalGamesPlayed;
            statTotalTime.textContent = formatTime(playerStats.totalTimePlayedSeconds);
            statBestTime3x3.textContent = formatTimeShort(playerStats.bestTime3x3Seconds);
            statBestMoves3x3.textContent = playerStats.bestMoves3x3 === Infinity ? translations[currentLanguage].notApplicable : playerStats.bestMoves3x3;
            // No Manhattan stats to update here
        }


        // =====================================================================
        // Handle "View Original Image" Button
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src) {
                mainContent.classList.add('main-content-hidden');
                originalImageDisplayContainer.classList.add('show');
                fullImageDisplay.src = originalImage.src;
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showMessageBox("noImageLoaded");
            }
        });
        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show');
            mainContent.classList.remove('main-content-hidden');
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' });
        });

        // =====================================================================
        // Image Cropper Logic
        // =====================================================================
        function setupCroppingInterface() {
            mainContent.classList.add('main-content-hidden');
            imageCropperContainer.style.display = 'flex';

            const maxWidth = cropperCanvas.parentElement.clientWidth * 0.9;
            const maxHeight = window.innerHeight * 0.7;
            
            let imgRatio = originalImage.width / originalImage.height;
            let canvasWidth = originalImage.width;
            let canvasHeight = originalImage.height;

            if (canvasWidth > maxWidth) {
                canvasWidth = maxWidth;
                canvasHeight = canvasWidth / imgRatio;
            }
            if (canvasHeight > maxHeight) {
                canvasHeight = maxHeight;
                canvasWidth = canvasHeight * imgRatio;
            }

            cropperCanvas.width = canvasWidth;
            cropperCanvas.height = canvasHeight;

            const minDim = Math.min(cropperCanvas.width, cropperCanvas.height);
            cropRect.size = minDim * 0.8;
            cropRect.x = (cropperCanvas.width / 2) - (cropRect.size / 2);
            cropRect.y = (cropperCanvas.height / 2) - (cropRect.size / 2);

            drawCropper();

            confirmCropButton.disabled = false;
            cancelCropButton.disabled = false;
        }

        function drawCropper() {
            cropperCtx.clearRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            cropperCtx.drawImage(originalImage, 0, 0, cropperCanvas.width, cropperCanvas.height);

            cropperCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            cropperCtx.fillRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            cropperCtx.globalCompositeOperation = 'destination-out';
            cropperCtx.fillRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);
            cropperCtx.globalCompositeOperation = 'source-over';

            cropperCtx.strokeStyle = '#fff';
            cropperCtx.lineWidth = 2;
            cropperCtx.strokeRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);

            const handleColor = currentTheme === 'dark' ? '#a78bfa' : '#6366f1';
            cropperCtx.fillStyle = handleColor;
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize);
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize);
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize);
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize);
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) * (canvas.width / rect.width),
                y: (evt.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const touch = evt.touches[0];
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        cropperCanvas.addEventListener('mousedown', handleCropStart);
        cropperCanvas.addEventListener('mousemove', handleCropMove);
        cropperCanvas.addEventListener('mouseup', handleCropEnd);
        cropperCanvas.addEventListener('mouseleave', handleCropEnd);

        cropperCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleCropStart(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleCropMove(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchend', handleCropEnd);

        function handleCropStart(e) {
            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            dragStartX = pos.x;
            dragStartY = pos.y;

            if (pos.x > cropRect.x + cropRect.size - resizeHandleSize && pos.x < cropRect.x + cropRect.size + resizeHandleSize &&
                pos.y > cropRect.y + cropRect.size - resizeHandleSize && pos.y < cropRect.y + cropRect.size + resizeHandleSize) {
                isResizing = true;
            } else if (pos.x > cropRect.x && pos.x < cropRect.x + cropRect.size &&
                       pos.y > cropRect.y && pos.y < cropRect.y + cropRect.size) {
                isDragging = true;
            }
        }

        function handleCropMove(e) {
            if (!isDragging && !isResizing) return;

            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;

            if (isDragging) {
                cropRect.x += dx;
                cropRect.y += dy;

                cropRect.x = Math.max(0, Math.min(cropRect.x, cropperCanvas.width - cropRect.size));
                cropRect.y = Math.max(0, Math.min(cropRect.y, cropperCanvas.height - cropRect.size));
            } else if (isResizing) {
                let newSize = Math.max(20, cropRect.size + dx);
                newSize = Math.max(newSize, cropRect.size + dy);

                newSize = Math.min(newSize, cropperCanvas.width - cropRect.x);
                newSize = Math.min(newSize, cropperCanvas.height - cropRect.y);

                cropRect.size = newSize;
            }

            dragStartX = pos.x;
            dragStartY = pos.y;

            drawCropper();
        }

        function handleCropEnd() {
            isDragging = false;
            isResizing = false;
        }

        confirmCropButton.addEventListener('click', async () => {
            const scaleX = originalImage.width / cropperCanvas.width;
            const scaleY = originalImage.height / cropperCanvas.height;

            finalSourceX = cropRect.x * scaleX;
            finalSourceY = cropRect.y * scaleY;
            finalSourceWidth = cropRect.size * scaleX;
            finalSourceHeight = cropRect.size * scaleY;

            imageCropperContainer.style.display = 'none';
            mainContent.classList.remove('main-content-hidden');
            
            initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
            await animateShuffle();
            enableAllButtons();
        });

        cancelCropButton.addEventListener('click', () => {
            imageCropperContainer.style.display = 'none';
            mainContent.classList.remove('main-content-hidden');
            showMessageBox("cropCancelled");
            if (!puzzleReady) {
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            }
            enableAllButtons();
        });

        // =====================================================================
        // Move History Functionality
        // =====================================================================
        function getDirectionSVG(direction) {
            const color = currentTheme === 'dark' ? '#8b5cf6' : '#6366f1';
            const size = 16;
            let transform = '';

            switch (direction) {
                case 'Right': transform = 'rotate(90)'; break;
                case 'Left': transform = 'rotate(-90)'; break;
                case 'Down': transform = 'rotate(180)'; break;
                case 'Up': transform = 'rotate(0)'; break;
                default: return '';
            }

            return `
                <svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transform: ${transform};">
                    <line x1="12" y1="19" x2="12" y2="5"></line>
                    <polyline points="5 12 12 5 19 12"></polyline>
                </svg>
            `;
        }

        function addMoveToHistory(pieceNumber, fromIndex, toIndex, currentGridSize) {
            const fromRow = Math.floor(fromIndex / currentGridSize);
            const fromCol = fromIndex % currentGridSize;
            const toRow = Math.floor(toIndex / currentGridSize);
            const toCol = toIndex % currentGridSize;

            let directionKey = '';
            if (fromRow === toRow) {
                directionKey = fromCol < toCol ? 'directionRight' : 'directionLeft';
            } else {
                directionKey = fromRow < toRow ? 'directionDown' : 'directionUp';
            }

            const moveText = translations[currentLanguage].pieceMoved(pieceNumber, translations[currentLanguage][directionKey]);
            const moveObject = { 
                text: moveText, 
                direction: translations[currentLanguage][directionKey]
            };
            
            moveHistory.unshift(moveObject);
            if (moveHistory.length > maxMoveHistory) {
                moveHistory.pop();
            }
            renderMoveHistory();
        }

        function renderMoveHistory() {
            moveHistoryList.innerHTML = '';
            if (moveHistory.length === 0) {
                moveHistoryList.innerHTML = `<li class="text-center text-secondary">${translations[currentLanguage].noMovesYet}</li>`;
                return;
            }
            moveHistory.forEach(move => {
                const listItem = document.createElement('li');
                listItem.innerHTML = `${getDirectionSVG(move.direction)} ${move.text}`;
                moveHistoryList.appendChild(listItem);
            });
        }

        // =====================================================================
        // Draw Moves Per Time Graph
        // =====================================================================
        function drawMovesPerTimeGraph() {
            movesPerTimeGraphSVG.innerHTML = '';
            if (movesPerIntervalData.length < 1) { // Need at least one data point to show something
                return;
            }

            const svgWidth = movesPerTimeGraphSVG.clientWidth;
            const svgHeight = movesPerTimeGraphSVG.clientHeight;
            const padding = 20;

            const times = movesPerIntervalData.map(d => d.time);
            const movesInIntervals = movesPerIntervalData.map(d => d.moves);

            const maxTime = Math.max(...times);
            const maxMoves = Math.max(...movesInIntervals);
            const minMoves = Math.min(...movesInIntervals);

            // If only one data point, or all moves are 0, prevent division by zero
            const xScale = (svgWidth - 2 * padding) / (maxTime || 1);
            const yScale = (svgHeight - 2 * padding) / (maxMoves - minMoves || 1);

            let pathData = '';
            if (movesPerIntervalData.length > 0) {
                // Map data points to SVG coordinates
                const points = movesPerIntervalData.map(d => {
                    const x = padding + d.time * xScale;
                    // Invert Y-axis for "trading bar" effect: higher moves means higher on graph
                    const y = svgHeight - padding - (d.moves - minMoves) * yScale;
                    return { x, y };
                });

                // Create path data for the line
                pathData = `M ${points[0].x} ${points[0].y}`;
                for (let i = 1; i < points.length; i++) {
                    pathData += ` L ${points[i].x} ${points[i].y}`;
                }

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                path.setAttribute("d", pathData);
                path.setAttribute("class", "moves-graph-line");
                movesPerTimeGraphSVG.appendChild(path);

                // Draw points
                points.forEach(point => {
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", point.x);
                    circle.setAttribute("cy", point.y);
                    circle.setAttribute("class", "moves-graph-point");
                    movesPerTimeGraphSVG.appendChild(circle);
                });
            }
        }

        // =====================================================================
        // Progress Indicator Functions
        // =====================================================================
        function updateProgressIndicator() {
            let correctPieces = 0;
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id === currentPieceIndex) {
                    correctPieces++;
                }
            }
            const progressPercentage = Math.floor((correctPieces / totalPieces) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
        }

        // =====================================================================
        // Confetti Animation Functions
        // =====================================================================
        function randomColor() {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722', '#795548', '#9e9e9e', '#607d8b'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        class ConfettiParticle {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.velocity = {
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10 - 5
                };
                this.alpha = 1;
                this.gravity = 0.3;
                this.friction = 0.99;
            }

            update() {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.01;
            }

            draw() {
                confettiCtx.save();
                confettiCtx.globalAlpha = this.alpha;
                confettiCtx.beginPath();
                confettiCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                confettiCtx.fillStyle = this.color;
                confettiCtx.fill();
                confettiCtx.restore();
            }
        }

        function startConfetti() {
            stopConfetti();
            confettiParticles = [];
            const numberOfParticles = 100;
            const centerX = confettiCanvas.width / 2;
            const centerY = confettiCanvas.height / 2;

            for (let i = 0; i < numberOfParticles; i++) {
                confettiParticles.push(new ConfettiParticle(
                    centerX + (Math.random() - 0.5) * 100,
                    centerY + (Math.random() - 0.5) * 100,
                    Math.random() * 5 + 2,
                    randomColor()
                ));
            }

            function animateConfetti() {
                confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                for (let i = confettiParticles.length - 1; i >= 0; i--) {
                    const particle = confettiParticles[i];
                    particle.update();
                    particle.draw();

                    if (particle.alpha <= 0.1 || particle.y > confettiCanvas.height) {
                        confettiParticles.splice(i, 1);
                    }
                }

                if (confettiParticles.length > 0) {
                    confettiAnimationId = requestAnimationFrame(animateConfetti);
                } else {
                    stopConfetti();
                }
            }
            animateConfetti();
        }

        function stopConfetti() {
            if (confettiAnimationId) {
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null;
            }
            confettiParticles = [];
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        }


        // =====================================================================
        // Initial Page Load Setup
        // =====================================================================
        window.onload = async () => {
            loadPreferences();
            loadPlayerStatistics();
            updateTextContent();
            updatePlayerStatisticsDisplay();

            originalImage.onload = async () => {
                if (originalImage.width === originalImage.height) {
                    initializePuzzle(0, 0, originalImage.width, originalImage.height);
                } else {
                    setupCroppingInterface();
                }
            };
            originalImage.onerror = () => {
                showMessageBox("failedLoadImage");
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
                enableAllButtons();
            };
            const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
            const placeholderSize = fixedCanvasSize; 
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`; 
        };

    </script>
</body>
</html>

