<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta name="keywords" content="sliding puzzle, puzzle geser, game puzzle, puzzle foto, game online, puzzle interaktif, potong gambar, gratis">
    <meta name="author" content="hanzercopy.cloud">
    
    <!-- Open Graph / Facebook / LinkedIn -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://hanzercopy.cloud">
    <meta property="og:title" content="Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!">
    <meta property="og:description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta property="og:image" content="https://placehold.co/1200x630/e0e7ff/4f46e5?text=Sliding%20Puzzle"> <!-- Ganti dengan URL gambar pratinjau Anda -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif';
            background-attachment: fixed; /* Memastikan gradient tetap saat scroll */
            overflow-x: hidden; /* Mencegah overflow horizontal */
            transition: background-color 0.3s ease, color 0.3s ease; /* Transisi tema */
        }
        /* Tema Terang (Default) */
        body.light-theme {
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1); /* Ungu-biru gradient */
            color: #1a202c; /* Teks gelap */
        }
        body.light-theme .main-container {
            background-color: #ffffff; /* Latar belakang putih */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        body.light-theme .text-primary {
            color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .text-secondary {
            color: #6b7280; /* Gray-500 */
        }
        body.light-theme .canvas-border {
            border-color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .canvas-bg {
            background-color: #ffffff;
        }
        body.light-theme .message-box, body.light-theme .confirmation-box, body.light-theme .cropper-content, body.light-theme #moveHistoryContainer, body.light-theme #playerStatsContainer {
            background-color: #fff;
            border-color: #4f46e5;
        }
        body.light-theme #moveHistoryContainer, body.light-theme #playerStatsContainer {
            background-color: #f8fafc;
        }
        body.light-theme .sample-image-container:hover {
            border-color: #6366f1;
        }
        body.light-theme .puzzle-solved-animation {
            border-color: #10b981; /* Green-500 */
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5);
        }
        body.light-theme .moves-time-text {
            color: #4f46e5; /* Indigo-600 */
        }
        body.light-theme .piece-number-color {
            color: #312e81; /* Darker indigo */
        }

        /* Tema Gelap */
        body.dark-theme {
            background-color: #1a202c; /* Darker background */
            background-image: none; /* Remove gradient */
            color: #e2e8f0; /* Light text */
        }
        body.dark-theme .main-container {
            background-color: #2d3748; /* Darker container */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.15);
        }
        body.dark-theme .text-primary {
            color: #6366f1; /* Indigo-500, similar to light theme primary */
        }
        body.dark-theme .text-secondary {
            color: #a0aec0; /* Light gray */
        }
        body.dark-theme .canvas-border {
            border-color: #4f46e5; /* Indigo-600, similar to light theme */
        }
        body.dark-theme .canvas-bg {
            background-color: #2d3748; /* Darker canvas background */
        }
        body.dark-theme .message-box, body.dark-theme .confirmation-box, body.dark-theme .cropper-content, body.dark-theme #moveHistoryContainer, body.dark-theme #playerStatsContainer {
            background-color: #2d3748;
            border-color: #4f46e5; /* Indigo-600 */
            color: #e2e8f0;
        }
        body.dark-theme #moveHistoryContainer, body.dark-theme #playerStatsContainer {
            background-color: #1a202c;
        }
        body.dark-theme .sample-image-container:hover {
            border-color: #6366f1; /* Indigo-500 */
        }
        body.dark-theme .puzzle-solved-animation {
            border-color: #8b5cf6; /* Violet-500 for solved state */
            box-shadow: 0 0 20px 5px rgba(139, 92, 246, 0.7), 0 0 30px 10px rgba(139, 92, 246, 0.5); /* Glowing effect */
        }
        body.dark-theme .moves-time-text {
            color: #fff; /* White text for numbers */
        }
        body.dark-theme .piece-number-color {
            color: #a78bfa; /* Violet-400 */
        }

        /* Styling untuk canvas */
        canvas {
            display: block; /* Menghilangkan spasi ekstra di bawah canvas */
            border: 3px solid; /* Border */
            border-radius: 0.75rem; /* Sudut membulat */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: manipulation; /* Memungkinkan event sentuhan */
            -webkit-user-select: none; /* Non-seleksi teks untuk iOS */
            -moz-user-select: none; /* Non-seleksi teks untuk Firefox */
            -ms-user-select: none; /* Non-seleksi teks untuk IE/Edge */
            user-select: none; /* Non-seleksi teks */
            /* Transisi untuk animasi kemenangan */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        .message-box, .confirmation-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid; /* Border */
            width: 90%;
            max-width: 400px;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        /* Styling untuk tombol */
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Indigo ke Violet */
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Lebih gelap saat hover */
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6); /* Lebih gelap lagi saat ditekan */
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button Gradients for Shuffle/Replay */
        .dark-theme .btn-primary-gradient {
            background-image: linear-gradient(to right, #4A90E2, #6A5ACD); /* Vibrant Blue to Medium Purple */
        }
        .dark-theme .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #3A7CD1, #5A4ABF); /* Darker shades */
        }
        .dark-theme .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #2A6AB0, #4A3A9E); /* Even darker shades */
            transform: scale(0.98);
        }


        .btn-purple {
            background-color: #a855f7; /* Purple-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-purple:hover {
            background-color: #9333ea; /* Purple-600 */
        }
        .btn-purple:active {
            background-color: #7e22ce; /* Purple-700 saat ditekan */
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button for Undo */
        .dark-theme .btn-purple {
            background-color: #9370DB; /* MediumPurple */
        }
        .dark-theme .btn-purple:hover {
            background-color: #7B5ECF; /* Darker MediumPurple */
        }
        .dark-theme .btn-purple:active {
            background-color: #644CA3; /* Even Darker MediumPurple */
            transform: scale(0.98);
        }


        .btn-green-solve {
            background-color: #10b981; /* Green-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-green-solve:hover {
            background-color: #059669;
        }
        .btn-green-solve:active {
            background-color: #047857;
            transform: scale(0.98);
        }
        /* Dark Theme Specific Button for Solve/Share */
        .dark-theme .btn-green-solve {
            background-image: linear-gradient(to right, #20B2AA, #3CB371); /* LightSeaGreen to MediumSeaGreen */
        }
        .dark-theme .btn-green-solve:hover {
            background-image: linear-gradient(to right, #1A908A, #329A5C); /* Darker shades */
        }
        .dark-theme .btn-green-solve:active {
            background-image: linear-gradient(to right, #146D66, #287A47); /* Even darker shades */
            transform: scale(0.98);
        }

        .btn-gray { /* General gray button for Reset */
            background-color: #6b7280; /* Gray-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .btn-gray:active {
            background-color: #374151; /* Gray-700 saat ditekan */
            transform: scale(0.98);
        }
        .dark-theme .btn-gray {
            background-color: #4a5568; /* Gray-700 */
        }
        .dark-theme .btn-gray:hover {
            background-color: #2d3748; /* Gray-800 */
        }
        .dark-theme .btn-gray:active {
            background-color: #1a202c; /* Gray-900 */
            transform: scale(0.98);
        }

        /* Styling untuk gambar contoh yang bisa diklik */
        .sample-image-container {
            width: 80px; /* Lebar tetap untuk gambar contoh */
            height: 80px; /* Tinggi tetap untuk gambar contoh */
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent; /* Border transparan default */
        }
        .sample-image-container:hover {
            transform: scale(1.05); /* Sedikit membesar saat hover */
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Pastikan gambar mengisi container tanpa distorsi */
            display: block;
        }


        /* Kelas untuk animasi kemenangan */
        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }

        /* Container untuk tampilan gambar asli di bawah */
        .original-image-display-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl; /* Match main container width */
        }
        .dark-theme .original-image-display-container {
            background-color: #2d3748;
        }
        .original-image-display-container.show {
            display: flex;
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0; /* Adjust margin if needed */
        }

        /* Kelas untuk menyembunyikan main-content saat gambar asli ditampilkan */
        .main-content-hidden {
            display: none;
        }

        /* Cropper Modal Styling */
        .cropper-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .cropper-content {
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #cropperCanvas {
            border: 2px solid;
            max-width: 100%;
            max-height: 60vh; /* Adjust as needed */
            display: block;
        }
        .light-theme #cropperCanvas {
            border-color: #6366f1;
            background-color: #f0f0f0;
        }
        .dark-theme #cropperCanvas {
            border-color: #4f46e5; /* Indigo-600 */
            background-color: #4a5568;
        }
        .cropper-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1002;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Move History Styling */
        #moveHistoryContainer {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid;
            border-radius: 0.5rem;
            padding: 0.75rem;
            font-size: 0.875rem;
            line-height: 1.5;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        /* Player Stats Styling */
        #playerStatsContainer {
            border: 1px solid;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1.5rem;
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
        }
        #playerStatsContainer ul {
            list-style: none;
            padding: 0;
        }
        #playerStatsContainer li {
            margin-bottom: 0.5rem;
        }
        #playerStatsContainer li span {
            font-weight: 600;
        }

        /* Share button styling */
        #shareLinkButton { /* Changed from #shareButton */
            /* display: none; */ /* Will be controlled by JS based on puzzle state */
            margin-top: 1rem;
        }

        /* Progress Indicator Styling */
        #progressIndicator {
            width: 100%;
            background-color: #e0e7ff; /* Light background for progress bar */
            border-radius: 9999px; /* Full rounded corners */
            height: 1.5rem; /* Height of the bar */
            overflow: hidden; /* Ensure inner bar stays within bounds */
            margin-bottom: 1rem;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }
        .dark-theme #progressIndicator {
            background-color: #4a5568; /* Darker background for dark theme */
        }

        #progressBar {
            height: 100%;
            width: 0%; /* Initial width */
            background-image: linear-gradient(to right, #818cf8, #6366f1); /* Blue-purple gradient */
            border-radius: 9999px;
            transition: width 0.5s ease-out; /* Smooth transition for width changes */
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.875rem; /* text-sm */
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .dark-theme #progressBar {
            background-image: linear-gradient(to right, #4A90E2, #6A5ACD); /* Dark theme gradient */
        }
        #progressText {
            padding-left: 0.5rem;
            padding-right: 0.5rem;
        }

        /* Confetti Canvas */
        #confettiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through */
            z-index: 1001; /* Above puzzle, below modals */
        }

    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <div id="mainContent" class="w-full max-w-3xl p-6 rounded-xl main-container">
        <h1 class="text-3xl font-bold text-center text-primary mb-6" data-key="mainTitle">Sliding Puzzle Interaktif</h1>

        <div class="mb-6 text-center">
            <label for="themeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectTheme">Pilih Tema:</label>
            <select id="themeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                <option value="light" data-key="lightTheme">Terang</option>
                <option value="dark" data-key="darkTheme">Gelap</option>
            </select>
        </div>

        <div class="mb-6 text-center">
            <label for="languageSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectLanguage">Pilih Bahasa:</label>
            <select id="languageSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                <option value="en">English</option>
                <option value="id">Indonesia</option>
                <option value="es">Español</option>
                <option value="ja">日本語</option>
            </select>
        </div>

        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-secondary mb-2" data-key="uploadPhoto">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
        </div>

        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-secondary mb-2" data-key="orSelectSample">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png" alt="Contoh Gambar 1" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png" alt="Contoh Gambar 2" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png" alt="Contoh Gambar 3" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png" alt="Contoh Gambar 4" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <div class="text-center">
                <label for="gridSizeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectPuzzleSize">Pilih Ukuran Puzzle:</label>
                <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                    <option value="3" selected>3x3</option>
                    <option value="4">4x4</option>
                    <option value="5">5x5</option>
                    <option value="6">6x6</option> <!-- New -->
                    <option value="7">7x7</option> <!-- New -->
                </select>
            </div>

            <div class="text-center">
                <label for="puzzleModeSelect" class="block text-lg font-medium text-secondary mb-2" data-key="selectPuzzleMode">Pilih Mode Puzzle:</label>
                <select id="puzzleModeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent bg-white text-gray-900 dark:bg-gray-700 dark:text-gray-100 dark:border-gray-600">
                    <option value="sliding" data-key="slidingPuzzle">Sliding Puzzle (Default)</option>
                    <option value="jigsaw" data-key="jigsaw">Jigsaw (Tanpa Nomor)</option>
                </select>
            </div>
        </div>
        
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-secondary">
                <span data-key="moves">Gerakan</span>: <span id="moveCounter" class="moves-time-text">0</span>
            </div>
            <div class="text-lg font-semibold text-secondary">
                <span data-key="time">Waktu</span>: <span id="timerDisplay" class="moves-time-text">00:00</span>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" data-key="shuffle">
                Acak
            </button>
            <button id="undoButton" class="btn-purple text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2" data-key="undo">
                Urungkan
            </button>
            <button id="solveButton" class="btn-green-solve text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" data-key="autoSolve">
                Selesaikan Otomatis
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2" data-key="resetPuzzle">
                Reset Puzzle
            </button>
        </div>
        <div id="solveStatus" class="text-center text-red-600 font-medium mb-4" style="min-height: 24px;"></div>

        <!-- Progress Indicator -->
        <div id="progressIndicator">
            <div id="progressBar">
                <span id="progressText">0%</span>
            </div>
        </div>

        <div class="relative w-full max-w-full flex justify-center items-center overflow-hidden mb-6" style="min-height: 250px;">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full canvas-border canvas-bg"></canvas>
            <canvas id="confettiCanvas"></canvas> <!-- Confetti canvas overlay -->
        </div>

        <div class="text-center mt-4 flex flex-wrap justify-center gap-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2" data-key="viewOriginalImage">
                Lihat Gambar Asli
            </button>
            <button id="replayButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" style="display: none;" data-key="replayMoves">
                Putar Ulang Gerakan
            </button>
            <button id="shareLinkButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2" data-key="sharePuzzleLink">
                Bagikan Tautan Puzzle
            </button>
        </div>
        
        <p class="text-center text-secondary text-sm italic mt-4" data-key="clickHint">Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.</p>

        <div class="mt-6">
            <h2 class="text-xl font-semibold text-secondary mb-2 text-center" data-key="moveHistoryTitle">Riwayat Gerakan Anda:</h2>
            <div id="moveHistoryContainer" class="p-3 rounded-lg shadow-inner">
                <ul id="moveHistoryList" class="list-disc list-inside text-secondary">
                    <!-- Move history items will be appended here -->
                </ul>
            </div>
        </div>

        <div id="playerStatsContainer" class="mt-6 p-4 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold text-secondary mb-3 text-center" data-key="playerStatsTitle">Statistik Pemain:</h2>
            <ul class="text-secondary">
                <li><span data-key="totalGamesPlayed">Total Game Dimainkan</span>: <span id="statTotalGames" class="font-bold text-primary">0</span></li>
                <li><span data-key="totalTimePlayed">Total Waktu Bermain</span>: <span id="statTotalTime" class="font-bold text-primary">00:00:00</span></li>
                <li><span data-key="bestTime3x3">Waktu Terbaik (3x3)</span>: <span id="statBestTime3x3" class="font-bold text-primary">--:--</span></li>
                <li><span data-key="bestMoves3x3">Gerakan Terbaik (3x3)</span>: <span id="statBestMoves3x3" class="font-bold text-primary">--</span></li>
            </ul>
        </div>
        
    </div>

    <div id="messageBoxContainer"></div>
    <div id="confirmationBoxContainer"></div>

    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="backToPuzzle">
            Kembali ke Puzzle
        </button>
    </div>

    <!-- Cropper Modal -->
    <div id="imageCropperContainer" class="cropper-modal" style="display: none;">
        <div class="cropper-content">
            <h2 class="text-2xl font-bold text-center text-primary mb-4" data-key="cropAreaTitle">Pilih Area Puzzle</h2>
            <canvas id="cropperCanvas"></canvas>
            <div class="cropper-controls">
                <button id="confirmCropButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="confirmCrop">
                    Konfirmasi Potongan
                </button>
                <button id="cancelCropButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md" data-key="cancel">
                    Batal
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p id="loadingMessage" data-key="loading">Memuat...</p>
    </div>


    <script type="module">
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const puzzleModeSelect = document.getElementById('puzzleModeSelect');
        const languageSelect = document.getElementById('languageSelect');
        const themeSelect = document.getElementById('themeSelect'); // New theme select
        const shuffleButton = document.getElementById('shuffleButton');
        const undoButton = document.getElementById('undoButton');
        const solveButton = document.getElementById('solveButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const confirmationBoxContainer = document.getElementById('confirmationBoxContainer');
        const moveCounterDisplay = document.getElementById('moveCounter');
        const timerDisplay = document.getElementById('timerDisplay');
        const solveStatusDisplay = document.getElementById('solveStatus');
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent');
        const replayButton = document.getElementById('replayButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const moveHistoryList = document.getElementById('moveHistoryList');
        const shareLinkButton = document.getElementById('shareLinkButton'); // Changed ID
        const progressBar = document.getElementById('progressBar'); // New progress bar
        const progressText = document.getElementById('progressText'); // New progress text
        const confettiCanvas = document.getElementById('confettiCanvas'); // Confetti canvas
        const confettiCtx = confettiCanvas.getContext('2d'); // Confetti context

        // Player Statistics elements
        const statTotalGames = document.getElementById('statTotalGames');
        const statTotalTime = document.getElementById('statTotalTime');
        const statBestTime3x3 = document.getElementById('statBestTime3x3');
        const statBestMoves3x3 = document.getElementById('statBestMoves3x3');

        // Cropper elements
        const imageCropperContainer = document.getElementById('imageCropperContainer');
        const cropperCanvas = document.getElementById('cropperCanvas');
        const cropperCtx = cropperCanvas.getContext('2d');
        const confirmCropButton = document.getElementById('confirmCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // Sample image elements
        const sampleImageContainers = document.querySelectorAll('.sample-image-container');
        let originalImage = new Image();
        let puzzlePieces = [];
        let gridSize = parseInt(gridSizeSelect.value);
        let currentPuzzleMode = puzzleModeSelect.value;
        let currentLanguage = 'en'; // Default language
        let currentTheme = 'light'; // Default theme
        const fixedCanvasSize = 1080; // Fixed to 1080x1080
        let pieceWidth;
        let pieceHeight;
        let blankPieceIndex;
        let isShuffled = false;
        let puzzleReady = false;
        let moves = 0;
        let isProcessingClick = false; // Flag for manual click animation
        let solving = false; // Flag for auto-solve process
        let shuffling = false; // Flag for initial shuffle animation
        let undoStack = [];
        const maxUndoStates = 50;

        let startTime;
        let timerInterval;
        let hasMadeFirstMove = false; // New flag for timer start
        const animationDuration = 200; // Manual move animation duration (ms)
        
        let hoveredPieceIndex = -1; // Variable to track currently hovered piece for visual effect
        let currentBase64Image = ''; // Global variable to store the current puzzle image as Base64

        // Dynamic shuffle animation parameters
        const getShuffleParams = (currentGridSize) => {
            switch (currentGridSize) {
                case 3: return { numMoves: 220, visualDelay: 16 }; // ~3.5s total (220 * 16ms)
                case 4: return { numMoves: 240, visualDelay: 17 }; // ~4s total (240 * 17ms)
                case 5: return { numMoves: 500, visualDelay: 10 }; // ~5s total (500 * 10ms)
                case 6: return { numMoves: 600, visualDelay: 8 }; // ~4.8s total
                case 7: return { numMoves: 700, visualDelay: 7 }; // ~4.9s total
                default: return { numMoves: 220, visualDelay: 16 };
            }
        };

        // Delay per gerakan untuk auto-solve, tergantung ukuran grid
        const getAutoSolveStepDelay = (currentGridSize) => {
            if (currentGridSize <= 4) return 150; // 0.15 seconds for smoother auto-solve
            if (currentGridSize === 5) return 350; // 0.35 seconds
            if (currentGridSize === 6) return 500; // 0.5 seconds
            if (currentGridSize === 7) return 700; // 0.7 seconds
            return 150; // Default
        };
        
        const maxStatesToExploreForBFS = 1000000;

        // Cropping variables
        let cropRect = { x: 0, y: 0, size: 0 }; // x, y, width/height of the square crop area
        let isDragging = false;
        let isResizing = false;
        let dragStartX, dragStartY;
        const resizeHandleSize = 10; // Size of the draggable corner for resizing

        // Source dimensions for puzzle pieces after cropping
        let finalSourceX = 0;
        let finalSourceY = 0;
        let finalSourceWidth = 0;
        let finalSourceHeight = 0;

        // Replay variables
        let replayMoves = []; // Stores { pieceId, fromIndex, toIndex } for each move
        let initialShuffledStateForReplay = []; // Stores the piece configuration right after shuffling
        let isReplaying = false; // New flag for replay mode

        let moveHistory = [];
        const maxMoveHistory = 10;

        // Player Statistics Object
        let playerStats = {
            totalGamesPlayed: 0,
            totalTimePlayedSeconds: 0,
            bestTime3x3Seconds: Infinity,
            bestMoves3x3: Infinity
        };

        // Confetti particles array
        let confettiParticles = [];
        let confettiAnimationId = null;

        // =====================================================================
        // Language Translations
        // =====================================================================
        const translations = {
            en: {
                mainTitle: "Interactive Sliding Puzzle",
                selectLanguage: "Select Language:",
                selectTheme: "Select Theme:", // New
                lightTheme: "Light", // New
                darkTheme: "Dark", // New
                uploadPhoto: "Upload Your Photo:",
                orSelectSample: "Or Select a Sample Image:",
                selectPuzzleSize: "Select Puzzle Size:",
                selectPuzzleMode: "Select Puzzle Mode:",
                slidingPuzzle: "Sliding Puzzle (Default)",
                jigsaw: "Jigsaw (No Numbers)",
                moves: "Moves",
                time: "Time",
                shuffle: "Shuffle",
                undo: "Undo",
                autoSolve: "Auto Solve",
                resetPuzzle: "Reset Puzzle",
                viewOriginalImage: "View Original Image",
                replayMoves: "Replay Moves",
                sharePuzzleLink: "Share Puzzle Link", // Changed from shareResult
                clickHint: "Click a piece adjacent to the empty space to move it.",
                moveHistoryTitle: "Your Move History:",
                noMovesYet: "No moves yet.",
                backToPuzzle: "Back to Puzzle",
                cropAreaTitle: "Select Puzzle Area",
                confirmCrop: "Confirm Crop",
                cancel: "Cancel",
                loading: "Loading...",
                loadingImage: "Loading image...",
                loadingSampleImage: "Loading sample image...",
                failedLoadImage: "Failed to load image. Please ensure it's a valid image file.",
                failedLoadSampleImage: "Failed to load sample image. Please try again or upload your own image.",
                shufflingPuzzle: "Shuffling puzzle...",
                // shuffleSuccess: (numMoves, time) => `Successfully shuffled ${numMoves} moves in ${time} seconds.`, // Removed
                shuffleFail: (attempts) => `Failed to find a solvable puzzle after ${attempts} attempts. Try shuffling again.`,
                noUndo: "No moves to undo.",
                confirmReset: "Are you sure you want to reset the puzzle? Your progress will be lost.",
                uploadImageFirst: "Please upload an image first.", // This message is now reused for "puzzle not ready"
                autoSolveConfirm: "Do you want the puzzle to be solved automatically? This will reset your moves.",
                autoSolveWarning5x5: "Warning: 5x5 Auto-Solve is Very Slow! Please be patient.",
                autoSolveWarning6x6: "Warning: 6x6 Auto-Solve is Extremely Slow! Please be patient.",
                autoSolveWarning7x7: "Warning: 7x7 Auto-Solve is Impractically Slow! Use with caution.",
                autoSolveSearching: "Searching for auto-solve solution...",
                solutionFound: (numMoves) => `Solution found! Playing ${numMoves} moves...`,
                errorPlayingSolution: "An error occurred while playing the solution.",
                solutionNotFound: "Solution not found within time/computation limits. Try shuffling again.",
                noReplayMoves: "No moves to replay.",
                replayFinished: "Replay finished.",
                puzzleSolved: (moves, time) => `Congratulations! Puzzle solved in ${moves} moves and ${time}!`,
                cropCancelled: "Cropping cancelled. Please upload or select another image.",
                noImageLoaded: "No image loaded to display.",
                pieceMoved: (pieceNumber, direction) => `Piece ${pieceNumber} moved ${direction}`,
                directionRight: "Right",
                directionLeft: "Left",
                directionDown: "Down",
                directionUp: "Up",
                shareLinkCopied: "Puzzle link copied to clipboard!", // New message for share link
                playerStatsTitle: "Player Statistics:", // New
                totalGamesPlayed: "Total Games Played", // New
                totalTimePlayed: "Total Time Played", // New
                bestTime3x3: "Best Time (3x3)", // New
                bestMoves3x3: "Best Moves (3x3)", // New
                notApplicable: "--", // New
                puzzleNotShuffled: "The puzzle is not shuffled yet. Please click 'Shuffle' to begin.", // New message
            },
            id: {
                mainTitle: "Sliding Puzzle Interaktif",
                selectLanguage: "Pilih Bahasa:",
                selectTheme: "Pilih Tema:", // New
                lightTheme: "Terang", // New
                darkTheme: "Gelap", // New
                uploadPhoto: "Unggah Foto Anda:",
                orSelectSample: "Atau Pilih Gambar Contoh:",
                selectPuzzleSize: "Pilih Ukuran Puzzle:",
                selectPuzzleMode: "Pilih Mode Puzzle:",
                slidingPuzzle: "Sliding Puzzle (Default)",
                jigsaw: "Jigsaw (Tanpa Nomor)",
                moves: "Gerakan",
                time: "Waktu",
                shuffle: "Acak",
                undo: "Urungkan",
                autoSolve: "Selesaikan Otomatis",
                resetPuzzle: "Reset Puzzle",
                viewOriginalImage: "Lihat Gambar Asli",
                replayMoves: "Putar Ulang Gerakan",
                sharePuzzleLink: "Bagikan Tautan Puzzle", // Changed from shareResult
                clickHint: "Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.",
                moveHistoryTitle: "Riwayat Gerakan Anda:",
                noMovesYet: "Belum ada gerakan.",
                backToPuzzle: "Kembali ke Puzzle",
                cropAreaTitle: "Pilih Area Puzzle",
                confirmCrop: "Konfirmasi Potongan",
                cancel: "Batal",
                loading: "Memuat...",
                loadingImage: "Memuat gambar...",
                loadingSampleImage: "Memuat gambar contoh...",
                failedLoadImage: "Gagal memuat gambar. Pastikan ini adalah file gambar yang valid.",
                failedLoadSampleImage: "Gagal memuat gambar contoh. Silakan coba lagi atau unggah gambar Anda sendiri.",
                shufflingPuzzle: "Mengacak puzzle...",
                // shuffleSuccess: (numMoves, time) => `Berhasil mengacak ${numMoves} gerakan dalam ${time} detik.`, // Removed
                shuffleFail: (attempts) => `Gagal menemukan puzzle yang dapat dipecahkan setelah ${attempts} percobaan. Coba acak ulang.`,
                noUndo: "Tidak ada gerakan untuk di-undo.",
                confirmReset: "Apakah Anda yakin ingin mereset puzzle? Progres Anda akan hilang.",
                uploadImageFirst: "Silakan unggah gambar terlebih dahulu.", // This message is now reused for "puzzle not ready"
                autoSolveConfirm: "Apakah Anda ingin puzzle diselesaikan secara otomatis? Ini akan mereset gerakan Anda.",
                autoSolveWarning5x5: "Peringatan: 5x5 Otomatis Sangat Lambat! Harap Bersabar.",
                autoSolveWarning6x6: "Peringatan: 6x6 Otomatis Sangat Lambat! Harap Bersabar.",
                autoSolveWarning7x7: "Peringatan: 7x7 Otomatis Sangat Tidak Praktis! Gunakan dengan hati-hati.",
                autoSolveSearching: "Mencari solusi otomatis...",
                solutionFound: (numMoves) => `Solusi ditemukan! Memainkan ${numMoves} gerakan...`,
                errorPlayingSolution: "Terjadi kesalahan saat memainkan solusi.",
                solutionNotFound: "Solusi tidak ditemukan dalam batas waktu/komputasi. Coba acak ulang.",
                noReplayMoves: "Tidak ada gerakan untuk diputar ulang.",
                replayFinished: "Pemutaran ulang selesai.",
                puzzleSolved: (moves, time) => `Selamat! Puzzle telah selesai dalam ${moves} gerakan dan waktu ${time}!`,
                cropCancelled: "Pemotongan dibatalkan. Silakan unggah atau pilih gambar lain.",
                noImageLoaded: "Tidak ada gambar yang dimuat untuk ditampilkan.",
                pieceMoved: (pieceNumber, direction) => `Potongan ${pieceNumber} bergerak ${direction}`,
                directionRight: "Kanan",
                directionLeft: "Kiri",
                directionDown: "Bawah",
                directionUp: "Atas",
                shareLinkCopied: "Tautan puzzle disalin ke clipboard!", // New message for share link
                playerStatsTitle: "Statistik Pemain:", // New
                totalGamesPlayed: "Total Game Dimainkan", // New
                totalTimePlayed: "Total Waktu Bermain", // New
                bestTime3x3: "Waktu Terbaik (3x3)", // New
                bestMoves3x3: "Gerakan Terbaik (3x3)", // New
                notApplicable: "--", // New
                puzzleNotShuffled: "Puzzle belum diacak. Silakan klik 'Acak' untuk memulai.", // New message
            },
            es: {
                mainTitle: "Rompecabezas Deslizante Interactivo",
                selectLanguage: "Seleccionar Idioma:",
                selectTheme: "Seleccionar Tema:", // New
                lightTheme: "Claro", // New
                darkTheme: "Oscuro", // New
                uploadPhoto: "Sube tu foto:",
                orSelectSample: "O Selecciona una Imagen de Ejemplo:",
                selectPuzzleSize: "Seleccionar Tamaño del Rompecabezas:",
                selectPuzzleMode: "Seleccionar Modo de Rompecabezas:",
                slidingPuzzle: "Rompecabezas Deslizante (Predeterminado)",
                jigsaw: "Rompecabezas (Sin Números)",
                moves: "Movimientos",
                time: "Tiempo",
                shuffle: "Barajar",
                undo: "Deshacer",
                autoSolve: "Resolver Automáticamente",
                resetPuzzle: "Reiniciar Rompecabezas",
                viewOriginalImage: "Ver Imagen Original",
                replayMoves: "Reproducir Movimientos",
                sharePuzzleLink: "Compartir Enlace del Rompecabezas", // Changed from shareResult
                clickHint: "Haz clic en una pieza adyacente al espacio vacío para moverla.",
                moveHistoryTitle: "Tu Historial de Movimientos:",
                noMovesYet: "Aún no hay movimientos.",
                backToPuzzle: "Volver al Rompecabezas",
                cropAreaTitle: "Seleccionar Área del Rompecabezas",
                confirmCrop: "Confirmar Recorte",
                cancel: "Cancelar",
                loading: "Cargando...",
                loadingImage: "Cargando imagen...",
                loadingSampleImage: "Cargando imagen de ejemplo...",
                failedLoadImage: "No se pudo cargar la imagen. Asegúrate de que sea un archivo de imagen válido.",
                failedLoadSampleImage: "No se pudo cargar la imagen de ejemplo. Inténtalo de nuevo o sube tu propia imagen.",
                shufflingPuzzle: "Barajando rompecabezas...",
                // shuffleSuccess: (numMoves, time) => `Se barajaron ${numMoves} movimientos en ${time} segundos.`, // Removed
                shuffleFail: (attempts) => `No se pudo encontrar un rompecabezas resoluble después de ${attempts} intentos. Intenta barajar de nuevo.",`,
                noUndo: "No hay movimientos para deshacer.",
                confirmReset: "¿Estás seguro de que quieres reiniciar el rompecabezas? Tu progreso se perderá.",
                uploadImageFirst: "Por favor, sube una imagen primero.", // This message is now reused for "puzzle not ready"
                autoSolveConfirm: "¿Quieres que el rompecabezas se resuelva automáticamente? Esto reiniciará tus movimientos.",
                autoSolveWarning5x5: "Advertencia: ¡La resolución automática 5x5 es muy lenta! Ten paciencia.",
                autoSolveWarning6x6: "Advertencia: ¡La resolución automática 6x6 es extremadamente lenta! Ten paciencia.",
                autoSolveWarning7x7: "Advertencia: ¡La resolución automática 7x7 es imprácticamente lenta! Úsala con precaución.",
                autoSolveSearching: "Buscando solución automática...",
                solutionFound: (numMoves) => `¡Solución encontrada! Reproduciendo ${numMoves} movimientos...`,
                errorPlayingSolution: "Ocurrió un error al reproducir la solución.",
                solutionNotFound: "Solución no encontrada dentro de los límites de tiempo/cálculo. Intenta barajar de nuevo.",
                noReplayMoves: "No hay movimientos para reproducir.",
                replayFinished: "Reproducción finalizada.",
                puzzleSolved: (moves, time) => `¡Felicidades! Rompecabezas resuelto en ${moves} movimientos y ${time}!`,
                cropCancelled: "Recorte cancelado. Por favor, sube o selecciona otra imagen.",
                noImageLoaded: "No hay imagen cargada para mostrar.",
                pieceMoved: (pieceNumber, direction) => `Pieza ${pieceNumber} movida ${direction}`,
                directionRight: "Derecha",
                directionLeft: "Izquierda",
                directionDown: "Abajo",
                directionUp: "Arriba",
                shareLinkCopied: "¡Enlace del rompecabezas copiado al portapapeles!", // New message for share link
                playerStatsTitle: "Estadísticas del Jugador:", // New
                totalGamesPlayed: "Total de Juegos Jugados", // New
                totalTimePlayed: "Tiempo Total Jugado", // New
                bestTime3x3: "Mejor Tiempo (3x3)", // New
                bestMoves3x3: "Mejores Movimientos (3x3)", // New
                notApplicable: "--", // New
                puzzleNotShuffled: "El rompecabezas aún no está barajado. Haz clic en 'Barajar' para empezar.", // New message
            },
            ja: {
                mainTitle: "インタラクティブスライディングパズル",
                selectLanguage: "言語を選択:",
                selectTheme: "テーマを選択:", // New
                lightTheme: "ライト", // New
                darkTheme: "ダーク", // New
                uploadPhoto: "写真をアップロード:",
                orSelectSample: "またはサンプル画像を選択:",
                selectPuzzleSize: "パズルサイズを選択:",
                selectPuzzleMode: "パズルモードを選択:",
                slidingPuzzle: "スライディングパズル（デフォルト）",
                jigsaw: "ジグソー（数字なし）",
                moves: "移動",
                time: "時間",
                shuffle: "シャッフル",
                undo: "元に戻す",
                autoSolve: "自動解決",
                resetPuzzle: "パズルをリセット",
                viewOriginalImage: "元の画像を見る",
                replayMoves: "動きを再生",
                sharePuzzleLink: "パズルリンクを共有", // Changed from shareResult
                clickHint: "空のスペースに隣接するピースをクリックして移動します。",
                moveHistoryTitle: "あなたの移動履歴:",
                noMovesYet: "まだ動きはありません。",
                backToPuzzle: "パズルに戻る",
                cropAreaTitle: "パズル領域を選択",
                confirmCrop: "トリミングを確定",
                cancel: "キャンセル",
                loading: "読み込み中...",
                loadingImage: "画像を読み込み中...",
                loadingSampleImage: "サンプル画像を読み込み中...",
                failedLoadImage: "画像の読み込みに失敗しました。有効な画像ファイルであることを確認してください。",
                failedLoadSampleImage: "サンプル画像の読み込みに失敗しました。もう一度試すか、ご自身の画像をアップロードしてください。",
                shufflingPuzzle: "パズルをシャッフル中...",
                // shuffleSuccess: (numMoves, time) => `${numMoves}回の移動を${time}秒で正常にシャッフルしました。`, // Removed
                shuffleFail: (attempts) => `${attempts}回の試行後も解けるパズルが見つかりませんでした。もう一度シャッフルしてみてください。`,
                noUndo: "元に戻す動きはありません。",
                confirmReset: "パズルをリセットしてもよろしいですか？進行状況は失われます。",
                uploadImageFirst: "まず画像をアップロードしてください。", // This message is now reused for "puzzle not ready"
                autoSolveConfirm: "パズルを自動的に解決しますか？これにより、あなたの移動がリセットされます。",
                autoSolveWarning5x5: "警告：5x5の自動解決は非常に遅いです！しばらくお待ちください。",
                autoSolveWarning6x6: "警告：6x6の自動解決は非常に遅いです！しばらくお待ちください。",
                autoSolveWarning7x7: "警告：7x7の自動解決は実用的に遅いです！注意して使用してください。",
                autoSolveSearching: "自動解決策を検索中...",
                solutionFound: (numMoves) => `解決策が見つかりました！${numMoves}回の移動を再生中...`,
                errorPlayingSolution: "解決策の再生中にエラーが発生しました。",
                solutionNotFound: "時間/計算制限内で解決策が見つかりませんでした。もう一度シャッフルしてください。",
                noReplayMoves: "再生する動きはありません。",
                replayFinished: "再生が終了しました。",
                puzzleSolved: (moves, time) => `おめでとうございます！${moves}回の移動と${time}でパズルが解決しました！`,
                cropCancelled: "トリミングがキャンセルされました。別の画像をアップロードまたは選択してください。",
                noImageLoaded: "表示する画像が読み込まれていません。",
                pieceMoved: (pieceNumber, direction) => `ピース${pieceNumber}が${direction}に移動しました`,
                directionRight: "右",
                directionLeft: "左",
                directionDown: "下",
                directionUp: "上",
                shareLinkCopied: "パズルリンクがクリップボードにコピーされました！", // New message for share link
                playerStatsTitle: "プレイヤー統計:", // New
                totalGamesPlayed: "総プレイ回数", // New
                totalTimePlayed: "総プレイ時間", // New
                bestTime3x3: "ベストタイム (3x3)", // New
                bestMoves3x3: "ベストムーブ (3x3)", // New
                notApplicable: "--", // New
                puzzleNotShuffled: "パズルはまだシャッフルされていません。開始するには「シャッフル」をクリックしてください。", // New message
            }
        };

        // =====================================================================
        // Function to update all text content based on current language
        // =====================================================================
        function updateTextContent() {
            const elements = document.querySelectorAll('[data-key]');
            elements.forEach(element => {
                const key = element.getAttribute('data-key');
                if (translations[currentLanguage][key]) {
                    // Check if the translation is a function (like for shareMessage)
                    if (typeof translations[currentLanguage][key] === 'function') {
                        // For data-key elements, we just set the text content to the key itself
                        // The actual formatted message will be generated when needed (e.g., share button click)
                        element.textContent = translations[currentLanguage][key].name ? key : translations[currentLanguage][key]; // Fallback to key if it's a function without a name for display
                    } else {
                        element.textContent = translations[currentLanguage][key];
                    }
                }
            });

            // Update specific elements that have dynamic content or special cases
            document.getElementById('puzzleModeSelect').querySelector('option[value="sliding"]').textContent = translations[currentLanguage].slidingPuzzle;
            document.getElementById('puzzleModeSelect').querySelector('option[value="jigsaw"]').textContent = translations[currentLanguage].jigsaw;
            
            // Update theme options text
            document.getElementById('themeSelect').querySelector('option[value="light"]').textContent = translations[currentLanguage].lightTheme;
            document.getElementById('themeSelect').querySelector('option[value="dark"]').textContent = translations[currentLanguage].darkTheme;

            // Update placeholder text for image upload
            const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
            const placeholderSize = fixedCanvasSize;
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            
            renderMoveHistory(); // Re-render move history with updated language
            updatePlayerStatisticsDisplay(); // Re-render player stats with updated language
        }

        // =====================================================================
        // Handle Language Selection Change (with Local Storage)
        // =====================================================================
        languageSelect.addEventListener('change', (event) => {
            currentLanguage = event.target.value;
            savePreferences(); // Save preference
            updateTextContent();
        });

        // =====================================================================
        // Handle Theme Selection Change (with Local Storage)
        // =====================================================================
        themeSelect.addEventListener('change', (event) => {
            currentTheme = event.target.value;
            applyTheme(currentTheme);
            savePreferences(); // Save preference
            // Redraw puzzle to apply new number colors/strokes
            if (puzzleReady) {
                drawPuzzle();
            }
        });

        // =====================================================================
        // Apply Theme to Body
        // =====================================================================
        function applyTheme(themeName) {
            document.body.classList.remove('light-theme', 'dark-theme');
            document.body.classList.add(`${themeName}-theme`);
        }

        // =====================================================================
        // Utility function for notifications (replaces alert())
        // =====================================================================
        function showMessageBox(messageKey, ...args) {
            const message = typeof translations[currentLanguage][messageKey] === 'function' 
                            ? translations[currentLanguage][messageKey](...args) 
                            : translations[currentLanguage][messageKey];

            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Custom Confirmation Box
        // =====================================================================
        function showConfirmationBox(messageKey, onConfirmCallback) {
            const message = translations[currentLanguage][messageKey];
            const confirmationBox = document.createElement('div');
            confirmationBox.className = 'confirmation-box';
            confirmationBox.innerHTML = `
                <p class="text-xl font-semibold mb-6">${message}</p>
                <div class="flex justify-center gap-4">
                    <button id="confirmButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-md transition duration-300">${translations[currentLanguage].confirmCrop}</button>
                    <button id="cancelButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-md transition duration-300">${translations[currentLanguage].cancel}</button>
                </div>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            confirmationBoxContainer.appendChild(overlay);
            confirmationBoxContainer.appendChild(confirmationBox);

            document.getElementById('confirmButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
                onConfirmCallback();
            };
            document.getElementById('cancelButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Loading Indicator Functions
        // =====================================================================
        function showLoading(messageKey) {
            loadingMessage.textContent = translations[currentLanguage][messageKey];
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // =====================================================================
        // Function to check puzzle solvability
        // =====================================================================
        function isPuzzleSolvable(piecesArray, currentGridSize) {
            // Get the current order of original IDs of pieces
            const currentOrder = Array(currentGridSize * currentGridSize).fill(0);
            const piecePositions = new Map(); // Map originalId to current index in 1D array
            
            piecesArray.forEach(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                const index = row * currentGridSize + col;
                currentOrder[index] = p.id;
                piecePositions.set(p.id, index);
            });
            // Find the blank piece and its row (0-indexed from top)
            const blankPiece = piecesArray.find(p => p.isBlank);
            const blankIndex = piecePositions.get(blankPiece.id);
            const blankRowFromTop = Math.floor(blankIndex / currentGridSize);
            // Create a 1D array of non-blank piece IDs in their current reading order
            const flatState = currentOrder.filter(id => id !== blankPiece.id);
            let inversions = 0;
            for (let i = 0; i < flatState.length - 1; i++) {
                for (let j = i + 1; j < flatState.length; j++) {
                    if (flatState[i] > flatState[j]) {
                        inversions++;
                    }
                }
            }

            // Solvability rules based on grid size and blank tile position
            if (currentGridSize % 2 === 1) { // Odd grid size
                return inversions % 2 === 0;
            } else { // Even grid size
                const blankRowFromBottom = currentGridSize - blankRowFromTop; // 1-indexed from bottom
                if (blankRowFromBottom % 2 === 1) { // Blank on an odd row from bottom
                    return inversions % 2 === 0;
                } else { // Blank on an even row from bottom
                    return inversions % 2 === 1;
                }
            }
        }


        // =====================================================================
        // Handle Image Upload
        // =====================================================================
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                showLoading("loadingImage");
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage.onload = async () => { // Added async here
                        hideLoading();
                        // Check if image is already 1:1 aspect ratio
                        if (originalImage.width === originalImage.height) {
                            initializePuzzle(0, 0, originalImage.width, originalImage.height); // Use full image
                            await animateShuffle(); // Auto-shuffle after image load
                        } else {
                            setupCroppingInterface(); // Show cropper for non-square images
                        }
                    };
                    originalImage.onerror = () => {
                        hideLoading();
                        showMessageBox("failedLoadImage");
                        enableAllButtons();
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        // =====================================================================
        // Handle Sample Image Selection
        // =====================================================================
        sampleImageContainers.forEach(container => {
            container.addEventListener('click', async (event) => { // Added async here
                const imageUrl = container.dataset.src;
                if (!imageUrl) return;

                if (shuffling || solving || isProcessingClick || isReplaying) return; // Disable during replay

                showLoading("loadingSampleImage");
                disableAllButtons(); // Disable main buttons while loading/cropping

                originalImage.onload = async () => { // Added async here
                    hideLoading();
                    // Check if image is already 1:1 aspect ratio
                    if (originalImage.width === originalImage.height) {
                        initializePuzzle(0, 0, originalImage.width, originalImage.height); // Use full image
                        await animateShuffle(); // Auto-shuffle after image load
                    } else {
                        setupCroppingInterface(); // Show cropper for non-square images
                    }
                };
                originalImage.onerror = () => {
                    hideLoading();
                    showMessageBox("failedLoadSampleImage");
                    enableAllButtons();
                };
                originalImage.src = imageUrl;
            });
        });


        // =====================================================================
        // Handle Grid Size and Puzzle Mode Changes (with Local Storage)
        // =====================================================================
        gridSizeSelect.addEventListener('change', async (event) => {
            gridSize = parseInt(event.target.value);
            savePreferences(); // Save preference
            if (puzzleReady) {
                // When grid size changes, re-initialize to solved state and then auto-shuffle
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            }
        });

        puzzleModeSelect.addEventListener('change', async (event) => {
            currentPuzzleMode = event.target.value;
            savePreferences(); // Save preference
            if (puzzleReady) {
                // When mode changes, re-initialize to solved state and then auto-shuffle
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                drawPuzzle(); // Just redraw if no image is loaded yet
            }
        });

        // =====================================================================
        // Initialize Puzzle (Adapts image to 1:1, sets up pieces)
        // =====================================================================
        function initializePuzzle(srcX, srcY, srcW, srcH) {
            finalSourceX = srcX;
            finalSourceY = srcY;
            finalSourceWidth = srcW;
            finalSourceHeight = srcH;

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;
            confettiCanvas.width = fixedCanvasSize; // Set confetti canvas size
            confettiCanvas.height = fixedCanvasSize;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            puzzlePieces = [];
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < totalPieces; i++) {
                puzzlePieces.push({
                    id: i,
                    originalIndex: i, // Store original index to sort back to solved state
                    currentX: (i % gridSize) * pieceWidth,
                    currentY: Math.floor(i / gridSize) * pieceHeight,
                    sourceX: srcX + (srcW / gridSize) * (i % gridSize),
                    sourceY: srcY + (srcH / gridSize) * Math.floor(i / gridSize),
                    sourceWidth: srcW / gridSize,
                    sourceHeight: srcH / gridSize,
                    isBlank: false
                });
            }
            blankPieceIndex = totalPieces - 1;
            puzzlePieces[blankPieceIndex].isBlank = true;
            isShuffled = false; // Puzzle is in solved state by default
            moves = 0;
            undoStack = [];
            replayMoves = []; // Reset replay moves
            initialShuffledStateForReplay = []; // Reset initial state for replay
            replayButton.style.display = 'none'; // Hide replay button
            shareLinkButton.style.display = 'inline-block'; // Show share link button
            moveHistory = []; // Reset move history
            renderMoveHistory(); // Update UI
            updateMoveCounter();
            stopTimer(); // Ensure timer is stopped
            timerDisplay.textContent = '00:00';
            hasMadeFirstMove = false; // Reset first move flag for timer
            drawPuzzle(); // Draw in solved state
            updateProgressIndicator(); // Update progress to 0%
            hoveredPieceIndex = -1; // Reset hover state

            puzzleCanvas.classList.remove('puzzle-solved-animation');
            solveStatusDisplay.textContent = '';
            puzzleReady = true;
            enableAllButtons(); // Ensure buttons are enabled after puzzle initialization
            stopConfetti(); // Clear any existing confetti

            // After drawing the initial solved puzzle, capture its Base64 for sharing
            currentBase64Image = puzzleCanvas.toDataURL('image/png');
        }

        // =====================================================================
        // Recalculate piece positions and redraw (used for resize without resetting state)
        // =====================================================================
        function recalculatePiecePositionsAndRedraw() {
            if (!puzzleReady) return; // Only recalculate if puzzle is initialized

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;
            confettiCanvas.width = fixedCanvasSize; // Set confetti canvas size
            confettiCanvas.height = fixedCanvasSize;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            // Re-assign currentX/currentY for each piece based on its *current index in the puzzlePieces array*
            // This preserves the current (shuffled or solved) arrangement
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });

            drawPuzzle();
            updateProgressIndicator(); // Update progress on redraw
        }

        // =====================================================================
        // Draw Puzzle on Canvas
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
            puzzlePieces.forEach(piece => {
                if (!piece.isBlank) {
                    ctx.drawImage(
                        originalImage,
                        piece.sourceX, piece.sourceY,
                        piece.sourceWidth, piece.sourceHeight,
                        piece.currentX, piece.currentY,
                        pieceWidth, pieceHeight
                    );

                    // Draw border around pieces
                    const borderColor = currentTheme === 'dark' ? '#4f46e5' : '#6366f1'; // Indigo-600 for dark theme
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);

                    // Draw numbers only if not in Jigsaw mode
                    if (currentPuzzleMode === 'sliding') {
                        const fontSize = Math.min(pieceWidth, pieceHeight) * 0.3;
                        ctx.font = `${fontSize}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Fill text (always black for numbers)
                        ctx.fillStyle = '#000000'; // Black text for numbers
                        ctx.fillText(
                            piece.id + 1,
                            piece.currentX + pieceWidth / 2,
                            piece.currentY + pieceHeight / 2
                        );
                    }
                } else {
                    // Blank piece styling
                    const blankBgColor = currentTheme === 'dark' ? '#4a5568' : '#e0e7ff';
                    const blankBorderColor = currentTheme === 'dark' ? '#4f46e5' : '#6366f1'; // Indigo-600 for dark theme
                    ctx.fillStyle = blankBgColor;
                    ctx.fillRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    ctx.strokeStyle = blankBorderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                }
            });

            // Draw hover effect
            if (hoveredPieceIndex !== -1 && !isProcessingClick && !solving && !shuffling && !isReplaying) {
                const hoveredPiece = puzzlePieces.find(p => p.id === hoveredPieceIndex);
                if (hoveredPiece && !hoveredPiece.isBlank) {
                    const blankPiece = puzzlePieces.find(p => p.isBlank);
                    const hoveredPieceCol = Math.round(hoveredPiece.currentX / pieceWidth);
                    const hoveredPieceRow = Math.round(hoveredPiece.currentY / pieceHeight);
                    const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
                    const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

                    const isAdjacent = (
                        (Math.abs(hoveredPieceCol - blankPieceCol) === 1 && hoveredPieceRow === blankPieceRow) ||
                        (Math.abs(hoveredPieceRow - blankPieceRow) === 1 && hoveredPieceCol === blankPieceCol)
                    );

                    if (isAdjacent) {
                        ctx.strokeStyle = currentTheme === 'dark' ? '#9370DB' : '#a855f7'; // Purple for hover
                        ctx.lineWidth = 4; // Thicker border on hover
                        ctx.shadowColor = currentTheme === 'dark' ? 'rgba(147, 112, 219, 0.7)' : 'rgba(168, 85, 247, 0.7)'; // Matching shadow
                        ctx.shadowBlur = 10;
                        ctx.strokeRect(hoveredPiece.currentX, hoveredPiece.currentY, pieceWidth, pieceHeight);
                        ctx.shadowColor = 'transparent'; // Reset shadow
                        ctx.shadowBlur = 0; // Reset shadow
                    }
                }
            }
        }

        // =====================================================================
        // Shuffle Puzzle with visual animation and ensure solvability
        // =====================================================================
        async function animateShuffle() {
            if (!puzzleReady || shuffling || solving || isReplaying) { // Disable during replay
                return;
            }
            shuffling = true;
            showLoading("shufflingPuzzle");
            disableAllButtons();
            solveStatusDisplay.textContent = translations[currentLanguage].shufflingPuzzle;
            const originalBlankId = gridSize * gridSize - 1; // ID of the blank piece
            const { numMoves, visualDelay } = getShuffleParams(gridSize);
            const shuffleStartTime = Date.now();
            let currentSolvable = false;
            let shuffleAttempts = 0;
            const maxShuffleAttempts = 10; // Limit attempts for re-shuffling to find a solvable one

            let finalPuzzleOrder = null; // To store the *logical* order of piece IDs for the solvable state

            while (!currentSolvable && shuffleAttempts < maxShuffleAttempts) {
                // Reset puzzlePieces to the solved state (logically and visually) for this attempt's animation
                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                    piece.isBlank = (piece.id === originalBlankId);
                });
                drawPuzzle(); // Ensure it starts from solved for each attempt

                // Perform the visual shuffle animation for `numMoves`
                let currentVisualPieces = puzzlePieces.map(p => ({ ...p })); // Deep copy for animation state
                let currentVisualBlankPiece = currentVisualPieces.find(p => p.isBlank);
                for (let i = 0; i < numMoves; i++) {
                    if (!shuffling) { // Check if shuffle was externally stopped
                        break;
                    }

                    const blankCol = Math.round(currentVisualBlankPiece.currentX / pieceWidth);
                    const blankRow = Math.round(currentVisualBlankPiece.currentY / pieceHeight);

                    const possibleMoves = [];
                    if (blankRow > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow - 1));
                    if (blankRow < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow + 1));
                    if (blankCol > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol - 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    if (blankCol < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol + 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    const validMoves = possibleMoves.filter(p => p && !p.isBlank);

                    if (validMoves.length === 0) continue;

                    const pieceToMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    // Perform the swap of visual coordinates on `currentVisualPieces`
                    const tempX = pieceToMove.currentX;
                    const tempY = pieceToMove.currentY;

                    pieceToMove.currentX = currentVisualBlankPiece.currentX;
                    pieceToMove.currentY = currentVisualBlankPiece.currentY;

                    currentVisualBlankPiece.currentX = tempX;
                    currentVisualBlankPiece.currentY = tempY;
                    // Update the array order of `currentVisualPieces` to reflect the new visual positions
                    const pieceToMoveIndexInArray = currentVisualPieces.indexOf(pieceToMove);
                    const blankIndexInArray = currentVisualPieces.indexOf(currentVisualBlankPiece);
                    [currentVisualPieces[pieceToMoveIndexInArray], currentVisualPieces[blankIndexInArray]] = 
                    [currentVisualPieces[blankIndexInArray], currentVisualPieces[pieceToMoveIndexInArray]];
                    // Temporarily assign currentVisualPieces to puzzlePieces for drawing
                    puzzlePieces = currentVisualPieces;
                    drawPuzzle(); // Redraw after each step
                    await new Promise(resolve => setTimeout(resolve, visualDelay));
                }

                // After the visual animation, check if the resulting state is solvable
                if (isPuzzleSolvable(puzzlePieces, gridSize)) {
                    currentSolvable = true;
                    finalPuzzleOrder = puzzlePieces.map(p => p.id); // Store the IDs order of this solvable state
                } else {
                    shuffleAttempts++;
                    // If not solvable, the loop will restart, re-initializing and re-animating
                    console.warn(`Attempt ${shuffleAttempts}: Shuffled puzzle is not solvable. Retrying...`);
                }
            } // End of while loop (attempting to find a solvable animated shuffle)

            hideLoading();

            if (!shuffling) { // If shuffle was cancelled during animation
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                enableAllButtons();
                return;
            }

            if (currentSolvable && finalPuzzleOrder) {
                // Ensure `puzzlePieces` is exactly the solvable state found, even if visual steps deviated slightly
                let correctedPuzzlePieces = [];
                for (let i = 0; i < finalPuzzleOrder.length; i++) {
                    const pieceId = finalPuzzleOrder[i];
                    const originalPieceData = puzzlePieces.find(p => p.id === pieceId);
                    correctedPuzzlePieces.push({
                        ...originalPieceData,
                        currentX: (i % gridSize) * pieceWidth,
                        currentY: Math.floor(i / gridSize) * pieceHeight,
                        isBlank: (pieceId === originalBlankId)
                    });
                }
                puzzlePieces = correctedPuzzlePieces;
                drawPuzzle(); // Final draw to the guaranteed solvable state

                // const shuffleEndTime = Date.now(); // Removed this message
                // const elapsedTimeSeconds = ((shuffleEndTime - shuffleStartTime) / 1000).toFixed(2); // Removed this message

                isShuffled = true; // Set to true after successful shuffle
                moves = 0;
                undoStack = [];
                replayMoves = []; // Clear replay moves for a fresh game
                initialShuffledStateForReplay = puzzlePieces.map(p => ({ ...p })); // Store initial state for replay
                replayButton.style.display = 'none'; // Hide replay button
                shareLinkButton.style.display = 'inline-block'; // Show share link button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI
                updateMoveCounter();
                hasMadeFirstMove = false; // Reset for timer to start on first user move
                updateProgressIndicator(); // Update progress after shuffle
                hoveredPieceIndex = -1; // Reset hover state
                
                shuffling = false;
                enableAllButtons();

                // solveStatusDisplay.textContent = translations[currentLanguage].shuffleSuccess(numMoves, elapsedTimeSeconds); // Removed this line
                solveStatusDisplay.textContent = ''; // Clear status after shuffle
                
            } else {
                shuffling = false;
                enableAllButtons();
                solveStatusDisplay.textContent = translations[currentLanguage].shuffleFail(maxShuffleAttempts);
                showMessageBox("shuffleFail", maxShuffleAttempts);
                // Revert to initial state if cropping was done
                if (finalSourceWidth > 0 && finalSourceHeight > 0) {
                    initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                } else {
                    // If no image was properly loaded/cropped, show placeholder
                    const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                    const placeholderSize = fixedCanvasSize;
                    originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
                }
            }
        }


        shuffleButton.addEventListener('click', animateShuffle);
        // =====================================================================
        // Undo Puzzle Move
        // =====================================================================
        undoButton.addEventListener('click', () => {
            if (isProcessingClick || solving || shuffling || isReplaying) return; // Disable during replay

            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                puzzlePieces = prevState.pieces.map(p => ({ ...p }));
                moves = prevState.moves;
                isShuffled = prevState.isShuffled;
                currentPuzzleMode = prevState.puzzleMode;

                // Re-calculate positions based on the restored array order
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                });

                // Remove the last move from replay history as well
                if (replayMoves.length > 0) {
                    replayMoves.pop();
                }
                moveHistory.pop(); // Remove last move from history
                renderMoveHistory(); // Update UI

                updateMoveCounter();
                drawPuzzle();
                updateProgressIndicator(); // Update progress after undo
                puzzleModeSelect.value = currentPuzzleMode;
                hoveredPieceIndex = -1; // Reset hover state
            } else {
                showMessageBox("noUndo");
            }
        });

        // =====================================================================
        // Reset Puzzle to Original Order
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (isReplaying) return; // Disable during replay

            showConfirmationBox("confirmReset", () => {
                if (!puzzleReady) {
                    showMessageBox("uploadImageFirst");
                    return;
                }

                solving = false;
                shuffling = false;

                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);

                puzzlePieces.forEach((piece, index) => {
                    const targetCol = index % gridSize;
                    const targetRow = Math.floor(index / gridSize);
                    piece.currentX = targetCol * pieceWidth;
                    piece.currentY = targetRow * pieceHeight;
                });

                isShuffled = false;
                moves = 0;
                undoStack = [];
                replayMoves = []; // Reset replay moves
                initialShuffledStateForReplay = []; // Reset initial state for replay
                replayButton.style.display = 'none'; // Hide replay button
                shareLinkButton.style.display = 'inline-block'; // Show share link button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI
                updateMoveCounter();
                stopTimer();
                timerDisplay.textContent = '00:00';
                hasMadeFirstMove = false; // Reset first move flag
                drawPuzzle();
                updateProgressIndicator(); // Update progress to 0%
                puzzleCanvas.classList.remove('puzzle-solved-animation');
                solveStatusDisplay.textContent = '';
                stopConfetti(); // Stop any active confetti
                hoveredPieceIndex = -1; // Reset hover state

                enableAllButtons();
            });
        });


        // =====================================================================
        // Handle Puzzle Click/Touch (to move pieces)
        // =====================================================================
        puzzleCanvas.addEventListener('click', (event) => {
            // Only allow moves if puzzle is ready AND shuffled
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling || isReplaying) {
                if (puzzleReady && !isShuffled) {
                    showMessageBox("puzzleNotShuffled"); // Use the new, more accurate message
                }
                return;
            }
            isProcessingClick = true;

            // Start timer on first move
            if (!hasMadeFirstMove) {
                hasMadeFirstMove = true;
                startTimer();
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const clickedCol = Math.floor(mouseX / pieceWidth);
            const clickedRow = Math.floor(mouseY / pieceHeight);
            
            const clickedPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (clickedCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (clickedRow * pieceHeight)) < 1
            );
            if (!clickedPiece || clickedPiece.isBlank) {
                isProcessingClick = false;
                return;
            }

            const blankPiece = puzzlePieces.find(p => p.isBlank);
            const clickedPieceCol = Math.round(clickedPiece.currentX / pieceWidth);
            const clickedPieceRow = Math.round(clickedPiece.currentY / pieceHeight);
            const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
            const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

            const isAdjacent = (
                (Math.abs(clickedPieceCol - blankPieceCol) === 1 && clickedPieceRow === blankPieceRow) ||
                (Math.abs(clickedPieceRow - blankPieceRow) === 1 && clickedPieceCol === blankPieceCol)
            );
            if (isAdjacent) {
                const currentStatePieces = puzzlePieces.map(p => ({ ...p }));
                undoStack.push({ pieces: currentStatePieces, moves: moves, isShuffled: isShuffled, puzzleMode: currentPuzzleMode });
                if (undoStack.length > maxUndoStates) {
                    undoStack.shift();
                }

                const targetXForClicked = blankPiece.currentX;
                const targetYForClicked = blankPiece.currentY;
                const targetXForBlank = clickedPiece.currentX;
                const targetYForBlank = clickedPiece.currentY;

                // Record move for replay
                const fromIndex = clickedPieceRow * gridSize + clickedCol;
                const toIndex = blankPieceRow * gridSize + blankPieceCol;
                replayMoves.push({ pieceId: clickedPiece.id, fromIndex: fromIndex, toIndex: toIndex });
                addMoveToHistory(clickedPiece.id + 1, fromIndex, toIndex, gridSize); // Add to move history

                animatePieceMove(
                    clickedPiece, targetXForClicked, targetYForClicked,
                    blankPiece, targetXForBlank, targetYForBlank,
                    () => {
                        clickedPiece.currentX = targetXForClicked;
                        clickedPiece.currentY = targetYForClicked;
                        blankPiece.currentX = targetXForBlank;
                        blankPiece.currentY = targetYForBlank;

                        const clickedIndexInArray = puzzlePieces.indexOf(clickedPiece);
                        const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                        [puzzlePieces[clickedIndexInArray], puzzlePieces[blankIndexInArray]] = 
                        [puzzlePieces[blankIndexInArray], puzzlePieces[clickedIndexInArray]];

                        moves++;
                        updateMoveCounter();
                        drawPuzzle();
                        updateProgressIndicator(); // Update progress after move
                        checkWin();
                        isProcessingClick = false;
                    }
                );
            } else {
                isProcessingClick = false;
            }
        });

        // =====================================================================
        // Handle mouse/touch events for hover effect
        // =====================================================================
        puzzleCanvas.addEventListener('mousemove', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling || isReplaying) {
                if (hoveredPieceIndex !== -1) { // If a piece was hovered but interaction is now blocked
                    hoveredPieceIndex = -1;
                    drawPuzzle(); // Redraw to remove hover effect
                }
                return;
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const currentHoveredCol = Math.floor(mouseX / pieceWidth);
            const currentHoveredRow = Math.floor(mouseY / pieceHeight);
            
            const currentHoveredPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (currentHoveredCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (currentHoveredRow * pieceHeight)) < 1
            );

            let newHoveredIndex = -1;
            if (currentHoveredPiece && !currentHoveredPiece.isBlank) {
                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const hoveredPieceCol = Math.round(currentHoveredPiece.currentX / pieceWidth);
                const hoveredPieceRow = Math.round(currentHoveredPiece.currentY / pieceHeight);
                const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
                const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

                const isAdjacent = (
                    (Math.abs(hoveredPieceCol - blankPieceCol) === 1 && hoveredPieceRow === blankPieceRow) ||
                    (Math.abs(hoveredPieceRow - blankPieceRow) === 1 && hoveredPieceCol === blankPieceCol)
                );
                if (isAdjacent) {
                    newHoveredIndex = currentHoveredPiece.id;
                }
            }

            if (newHoveredIndex !== hoveredPieceIndex) {
                hoveredPieceIndex = newHoveredIndex;
                drawPuzzle(); // Redraw only if hover state changes
            }
        });

        puzzleCanvas.addEventListener('mouseout', () => {
            if (hoveredPieceIndex !== -1) {
                hoveredPieceIndex = -1;
                drawPuzzle(); // Redraw to remove hover effect
            }
        });

        // =====================================================================
        // Piece Movement Animation Function (for manual & auto-solve moves)
        // =====================================================================
        function animatePieceMove(piece1, targetX1, targetY1, piece2, targetX2, targetY2, callback) {
            const startX1 = piece1.currentX;
            const startY1 = piece1.currentY;
            const startX2 = piece2.currentX;
            const startY2 = piece2.currentY;

            let startTime = null;
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                piece1.currentX = startX1 + (targetX1 - startX1) * progress;
                piece1.currentY = startY1 + (targetY1 - startY1) * progress;
                piece2.currentX = startX2 + (targetX2 - startX2) * progress;
                piece2.currentY = startY2 + (targetY2 - startY2) * progress;
                
                drawPuzzle();
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback();
                }
            }
            requestAnimationFrame(animate);
        }

        // =====================================================================
        // Update Move Counter
        // =====================================================================
        function updateMoveCounter() {
            moveCounterDisplay.textContent = moves;
        }

        // =====================================================================
        // Timer Functions
        // =====================================================================
        function startTimer() {
            stopTimer();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');

            timerDisplay.textContent = `${formattedMinutes}:${formattedSeconds}`;
        }

        // =====================================================================
        // Check Win Condition & Display Win Animation
        // =====================================================================
        function checkWin() {
            if (!isShuffled) return;
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                // Check if the piece is in its correct original position
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id !== currentPieceIndex) {
                    solved = false;
                    break;
                }
            }

            if (solved) {
                isShuffled = false;
                stopTimer();
                hasMadeFirstMove = false; // Reset first move flag

                // Ensure the blank piece is visually at the last position for a truly solved look
                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const blankPieceCurrentIndexInArray = puzzlePieces.indexOf(blankPiece);
                const lastCorrectArrayPosition = puzzlePieces.length - 1;
                if (blankPieceCurrentIndexInArray !== lastCorrectArrayPosition) {
                    const pieceAtLastPosition = puzzlePieces[lastCorrectArrayPosition];
                    puzzlePieces[lastCorrectArrayPosition] = blankPiece;
                    puzzlePieces[blankPieceCurrentIndexInArray] = pieceAtLastPosition;

                    blankPiece.currentX = (lastCorrectArrayPosition % gridSize) * pieceWidth;
                    blankPiece.currentY = Math.floor(lastCorrectArrayPosition / gridSize) * pieceHeight;
                    pieceAtLastPosition.currentX = (blankPieceCurrentIndexInArray % gridSize) * pieceWidth;
                    pieceAtLastPosition.currentY = Math.floor(blankPieceCurrentIndexInArray / gridSize) * pieceHeight;
                }
                
                drawPuzzle();
                puzzleCanvas.classList.add('puzzle-solved-animation'); // Apply bounce animation
                startConfetti(); // Start confetti animation
                
                showMessageBox("puzzleSolved", moves, timerDisplay.textContent);
                
                enableAllButtons();
                solving = false;
                shuffling = false;
                isProcessingClick = false;
                hoveredPieceIndex = -1; // Reset hover state

                // Show replay button if there are moves to replay
                if (replayMoves.length > 0) {
                    replayButton.style.display = 'inline-block';
                }
                shareLinkButton.style.display = 'inline-block'; // Show share link button

                // Update player statistics
                updatePlayerStatistics(moves, Math.floor((Date.now() - startTime) / 1000));
                updateProgressIndicator(); // Update progress to 100%
            }
        }

        // =====================================================================
        // Disable all interactive buttons
        // =====================================================================
        function disableAllButtons() {
            shuffleButton.disabled = true;
            undoButton.disabled = true;
            solveButton.disabled = true;
            resetButton.disabled = false; // Reset button always remains active
            imageUpload.disabled = true;
            gridSizeSelect.disabled = true;
            puzzleModeSelect.disabled = true;
            viewOriginalImageButton.disabled = true;
            replayButton.disabled = true; // Disable replay button during operations
            shareLinkButton.disabled = true; // Disable share link button during operations
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'none');
            sampleImageContainers.forEach(container => container.style.opacity = '0.5');
            languageSelect.disabled = true; // Disable language select during operations
            themeSelect.disabled = true; // Disable theme select during operations
        }

        // =====================================================================
        // Enable all interactive buttons
        // =====================================================================
        function enableAllButtons() {
            shuffleButton.disabled = false;
            undoButton.disabled = false;
            solveButton.disabled = false; 
            resetButton.disabled = false;
            imageUpload.disabled = false;
            gridSizeSelect.disabled = false;
            puzzleModeSelect.disabled = false;
            viewOriginalImageButton.disabled = false;
            replayButton.disabled = false; // Enable replay button
            shareLinkButton.disabled = false; // Enable share link button
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'auto');
            sampleImageContainers.forEach(container => container.style.opacity = '1');
            languageSelect.disabled = false; // Enable language select
            themeSelect.disabled = false; // Enable theme select
        }

        // =====================================================================
        // Function to auto-solve puzzle using BFS (Breadth-First Search)
        // =====================================================================
        solveButton.addEventListener('click', () => {
            showConfirmationBox("autoSolveConfirm", async () => {
                await solvePuzzleAutomatically();
            });
        });

        async function solvePuzzleAutomatically() {
            if (!puzzleReady || !isShuffled || solving || shuffling || isReplaying) { // Disable during replay
                return;
            }

            solving = true;
            isProcessingClick = true;
            hasMadeFirstMove = true; // Auto-solve implies moves are being made, so start timer
            startTimer();
            if (gridSize === 7) {
                showLoading("autoSolveWarning7x7");
            } else if (gridSize === 6) {
                showLoading("autoSolveWarning6x6");
            } else if (gridSize === 5) {
                showLoading("autoSolveWarning5x5");
            } else {
                showLoading("autoSolveSearching");
            }
            
            disableAllButtons();
            resetButton.disabled = false;

            stopTimer(); // Temporarily stop timer during search, will restart for animation playback

            const queue = [];
            const visited = new Set();

            // Create a state array based on current positions (map original IDs to their current 1D index)
            const initialPiecesState = puzzlePieces.map(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                return { id: p.id, currentPos: row * gridSize + col };
            });
            initialPiecesState.sort((a, b) => a.currentPos - b.currentPos); // Sort by current position to get current "reading" order

            const initialOrderedIds = initialPiecesState.map(p => p.id);
            const blankId = puzzlePieces.find(p => p.isBlank).id;
            const initialBlankPos = initialOrderedIds.indexOf(blankId);

            queue.push({ state: initialOrderedIds, path: [], blankPos: initialBlankPos });
            visited.add(JSON.stringify(initialOrderedIds));
            let solutionPath = null;
            let count = 0; 

            while (queue.length > 0 && solving && count < maxStatesToExploreForBFS) {
                const { state, path, blankPos } = queue.shift();
                count++;

                const isSolved = state.every((id, index) => id === index);
                if (isSolved) {
                    solutionPath = path;
                    break;
                }

                const blankRow = Math.floor(blankPos / gridSize);
                const blankCol = blankPos % gridSize;

                const possibleSwapPositions = [];
                // Check neighbors: Up, Down, Left, Right
                if (blankRow > 0) possibleSwapPositions.push(blankPos - gridSize);
                if (blankRow < gridSize - 1) possibleSwapPositions.push(blankPos + gridSize); 
                if (blankCol > 0) possibleSwapPositions.push(blankPos - 1);
                if (blankCol < gridSize - 1) possibleSwapPositions.push(blankPos + 1); 

                for (const pieceToSwapIndex of possibleSwapPositions) {
                    const nextState = [...state];
                    // Swap the IDs in the new state array
                    const tempId = nextState[blankPos];
                    nextState[blankPos] = nextState[pieceToSwapIndex];
                    nextState[pieceToSwapIndex] = tempId;

                    const nextStateStr = JSON.stringify(nextState);
                    if (!visited.has(nextStateStr)) {
                        visited.add(nextStateStr);
                        queue.push({
                            state: nextState,
                            path: [...path, state[pieceToSwapIndex]], // Store the ID of the piece that moved into the blank spot
                            blankPos: pieceToSwapIndex 
                        });
                    }
                }
                if (count % 1000 === 0) { 
                    await new Promise(resolve => setTimeout(resolve, 0));
                    if (!solving) break; 
                }
            }

            hideLoading();

            if (!solving) { // If user cancelled auto-solve
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                return;
            }

            if (solutionPath) {
                solveStatusDisplay.textContent = translations[currentLanguage].solutionFound(solutionPath.length);
                const currentAutoSolveDelay = getAutoSolveStepDelay(gridSize);
                
                // Reset moves and replay history for auto-solve
                moves = 0;
                replayMoves = [];
                initialShuffledStateForReplay = []; // Clear initial state for auto-solve replay
                replayButton.style.display = 'none'; // Hide replay button
                shareLinkButton.style.display = 'inline-block'; // Show share link button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI

                // Re-start timer for animation playback
                startTimer();
                for (const pieceIdToMove of solutionPath) {
                    if (!solving) break; // Allow cancellation during playback

                    const pieceToMove = puzzlePieces.find(p => p.id === pieceIdToMove);
                    const blankPiece = puzzlePieces.find(p => p.isBlank);

                    if (!pieceToMove || !blankPiece) { 
                        console.error(translations[currentLanguage].errorPlayingSolution);
                        solving = false;
                        isProcessingClick = false;
                        enableAllButtons();
                        solveStatusDisplay.textContent = translations[currentLanguage].errorPlayingSolution;
                        stopTimer(); // Stop timer on error
                        hasMadeFirstMove = false;
                        return;
                    }
                    
                    const startX1 = pieceToMove.currentX;
                    const startY1 = pieceToMove.currentY;
                    const startX2 = blankPiece.currentX;
                    const startY2 = blankPiece.currentY;

                    const targetX1 = startX2; 
                    const targetY1 = startY2;
                    const targetX2 = startX1; 
                    const targetY2 = startY1; 

                    await new Promise(resolve => {
                        animatePieceMove(
                            pieceToMove, targetX1, targetY1,
                            blankPiece, targetX2, targetY2,
                            () => {
                                pieceToMove.currentX = targetX1;
                                pieceToMove.currentY = targetY1;
                                blankPiece.currentX = targetX2;
                                blankPiece.currentY = targetY2;

                                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                                const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                                [puzzlePieces[pieceToMoveCurrentIndex], puzzlePieces[blankIndexInArray]] =
                                [puzzlePieces[blankIndexInArray], puzzlePieces[pieceToMoveCurrentIndex]];

                                moves++;
                                updateMoveCounter();
                                drawPuzzle();
                                updateProgressIndicator(); // Update progress during auto-solve
                                resolve();
                            }
                        );
                    });
                    if (solving) { // Only pause if solving is still active
                        await new Promise(resolve => setTimeout(resolve, currentAutoSolveDelay));
                    }
                }
                if (solving) {
                    checkWin(); // Final check if solution playback completed
                }
            } else { 
                solveStatusDisplay.textContent = translations[currentLanguage].solutionNotFound;
                showMessageBox('solutionNotFound');
            }

            solving = false;
            isProcessingClick = false;
            enableAllButtons();
            // Timer is handled by checkWin or explicitly stopped on failure/cancellation
            if (isShuffled && !solving) { // If still shuffled and not in an active solve state
                startTimer(); // Ensure timer continues if not solved
            } else if (!isShuffled && !solving) { // If solved, ensure timer is stopped
                stopTimer();
                hasMadeFirstMove = false;
            }
        }
        
        // =====================================================================
        // Replay Functionality
        // =====================================================================
        replayButton.addEventListener('click', async () => {
            if (replayMoves.length === 0 || solving || shuffling || isProcessingClick) {
                showMessageBox("noReplayMoves");
                return;
            }

            isReplaying = true; // Set replay flag
            disableAllButtons(); // Disable all buttons
            stopTimer(); // Stop timer during replay
            solveStatusDisplay.textContent = translations[currentLanguage].replayFinished; // Keep this status, but no overlay

            // Reset puzzle to the initial shuffled state
            puzzlePieces = initialShuffledStateForReplay.map(p => ({ ...p }));
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });
            moves = 0;
            updateMoveCounter();
            drawPuzzle();
            updateProgressIndicator(); // Update progress for replay start
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            stopConfetti(); // Stop any active confetti
            hoveredPieceIndex = -1; // Reset hover state

            // Play back the moves
            for (const move of replayMoves) {
                if (!isReplaying) break; // Allow stopping replay if needed

                const pieceToMove = puzzlePieces.find(p => p.id === move.pieceId);
                const blankPiece = puzzlePieces.find(p => p.isBlank);

                if (!pieceToMove || !blankPiece) {
                    console.error("Error during replay: Piece or blank not found.");
                    break;
                }

                // Find current positions of pieceToMove and blankPiece in the array
                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                const blankPieceCurrentIndex = puzzlePieces.indexOf(blankPiece);

                // Calculate target positions based on the recorded move (fromIndex of the piece moved into blank)
                // The blank piece moves to the pieceToMove's original spot
                // The pieceToMove moves to the blank's original spot
                const targetXForMovedPiece = (move.toIndex % gridSize) * pieceWidth;
                const targetYForMovedPiece = Math.floor(move.toIndex / gridSize) * pieceHeight;
                const targetXForBlank = (move.fromIndex % gridSize) * pieceWidth;
                const targetYForBlank = Math.floor(move.fromIndex / gridSize) * pieceHeight;

                await new Promise(resolve => {
                    animatePieceMove(
                        pieceToMove, targetXForMovedPiece, targetYForMovedPiece,
                        blankPiece, targetXForBlank, targetYForBlank,
                        () => {
                            // Update actual positions after animation
                            pieceToMove.currentX = targetXForMovedPiece;
                            pieceToMove.currentY = targetYForMovedPiece;
                            blankPiece.currentX = targetXForBlank;
                            blankPiece.currentY = targetYForBlank;

                            // Swap their positions in the array
                            const newPieceToMoveIndex = puzzlePieces.indexOf(pieceToMove); // Should be blankPieceCurrentIndex
                            const newBlankPieceIndex = puzzlePieces.indexOf(blankPiece); // Should be pieceToMoveCurrentIndex
                            [puzzlePieces[newPieceToMoveIndex], puzzlePieces[newBlankPieceIndex]] =
                            [puzzlePieces[newBlankPieceIndex], puzzlePieces[newPieceToMoveIndex]];

                            moves++; // Increment moves for replay visual, though not actual game moves
                            updateMoveCounter();
                            drawPuzzle();
                            updateProgressIndicator(); // Update progress during replay
                            resolve();
                        }
                    );
                });
                await new Promise(resolve => setTimeout(resolve, 300)); // Delay between replay moves
            }

            isReplaying = false; // Reset replay flag
            solveStatusDisplay.textContent = translations[currentLanguage].replayFinished;
            // After replay, the puzzle should be solved
            checkWin(); // This will re-enable buttons and handle final state
            // Ensure buttons are re-enabled after replay finishes
            enableAllButtons();
        });


        // =====================================================================
        // Handle Window Resize Responsiveness
        // =====================================================================
        window.addEventListener('resize', async () => {
            if (!puzzleReady) return; // Don't do anything if puzzle isn't ready

            solving = false;
            isProcessingClick = false;
            isReplaying = false; // Stop replay on resize
            
            enableAllButtons(); // Re-enable in case they were disabled by auto-solve/click animation
            solveStatusDisplay.textContent = '';
            puzzleCanvas.classList.remove('puzzle-solved-animation');
            stopConfetti(); // Stop any active confetti
            hoveredPieceIndex = -1; // Reset hover state

            recalculatePiecePositionsAndRedraw(); // Always redraw to fit new canvas size, preserving current state
        });
        // =====================================================================
        // Local Storage Functions for Preferences and Player Stats
        // =====================================================================
        function savePreferences() {
            localStorage.setItem('puzzleGridSize', gridSizeSelect.value);
            localStorage.setItem('puzzleMode', puzzleModeSelect.value);
            localStorage.setItem('puzzleLanguage', currentLanguage);
            localStorage.setItem('puzzleTheme', currentTheme); // Save theme
        }

        function loadPreferences() {
            const savedGridSize = localStorage.getItem('puzzleGridSize');
            const savedPuzzleMode = localStorage.getItem('puzzleMode');
            const savedLanguage = localStorage.getItem('puzzleLanguage');
            const savedTheme = localStorage.getItem('puzzleTheme'); // Load theme

            if (savedGridSize) {
                gridSizeSelect.value = savedGridSize;
                gridSize = parseInt(savedGridSize);
            }
            if (savedPuzzleMode) {
                puzzleModeSelect.value = savedPuzzleMode;
                currentPuzzleMode = savedPuzzleMode;
            }
            if (savedLanguage && translations[savedLanguage]) {
                currentLanguage = savedLanguage;
                languageSelect.value = savedLanguage;
            } else {
                currentLanguage = 'en'; // Default to English if no saved language or invalid
                languageSelect.value = 'en';
            }
            if (savedTheme) {
                currentTheme = savedTheme;
                themeSelect.value = savedTheme;
            } else {
                currentTheme = 'light'; // Default to light theme
                themeSelect.value = 'light';
            }
            applyTheme(currentTheme); // Apply the loaded theme immediately
        }

        function loadPlayerStatistics() {
            const savedStats = localStorage.getItem('playerStats');
            if (savedStats) {
                playerStats = JSON.parse(savedStats);
                // Ensure Infinity values are correctly parsed back if they were stringified as null/0
                if (playerStats.bestTime3x3Seconds === null || playerStats.bestTime3x3Seconds === 0) {
                    playerStats.bestTime3x3Seconds = Infinity;
                }
                if (playerStats.bestMoves3x3 === null || playerStats.bestMoves3x3 === 0) {
                    playerStats.bestMoves3x3 = Infinity;
                }
            }
        }

        function savePlayerStatistics() {
            // Convert Infinity to null or a large number for JSON stringify if needed,
            // but JSON.stringify handles Infinity as "null" by default for numbers.
            // When parsing back, we convert null/0 back to Infinity.
            localStorage.setItem('playerStats', JSON.stringify(playerStats));
        }

        function updatePlayerStatistics(currentMoves, currentTimeSeconds) {
            playerStats.totalGamesPlayed++;
            playerStats.totalTimePlayedSeconds += currentTimeSeconds;

            if (gridSize === 3) {
                if (currentTimeSeconds < playerStats.bestTime3x3Seconds) {
                    playerStats.bestTime3x3Seconds = currentTimeSeconds;
                }
                if (currentMoves < playerStats.bestMoves3x3) {
                    playerStats.bestMoves3x3 = currentMoves;
                }
            }
            savePlayerStatistics();
            updatePlayerStatisticsDisplay();
        }

        function formatTime(totalSeconds) {
            if (totalSeconds === Infinity) return translations[currentLanguage].notApplicable;
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const formattedHours = String(hours).padStart(2, '0');
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            return `${formattedHours}:${formattedMinutes}:${formattedSeconds}`;
        }

        function formatTimeShort(totalSeconds) {
            if (totalSeconds === Infinity) return translations[currentLanguage].notApplicable;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');
            return `${formattedMinutes}:${formattedSeconds}`;
        }

        function updatePlayerStatisticsDisplay() {
            statTotalGames.textContent = playerStats.totalGamesPlayed;
            statTotalTime.textContent = formatTime(playerStats.totalTimePlayedSeconds);
            statBestTime3x3.textContent = formatTimeShort(playerStats.bestTime3x3Seconds);
            statBestMoves3x3.textContent = playerStats.bestMoves3x3 === Infinity ? translations[currentLanguage].notApplicable : playerStats.bestMoves3x3;
        }


        // =====================================================================
        // Handle "View Original Image" Button
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src) {
                mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
                originalImageDisplayContainer.classList.add('show'); // Show original image container
                fullImageDisplay.src = originalImage.src; // Ensure image is displayed
                // Scroll to the top of the original image container
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showMessageBox("noImageLoaded");
            }
        });
        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show'); // Hide original image container
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            // Scroll to the puzzle canvas for better context
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' }); // block: 'center' tries to center it
        });

        // =====================================================================
        // Image Cropper Logic
        // =====================================================================
        function setupCroppingInterface() {
            mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
            imageCropperContainer.style.display = 'flex'; // Show cropper modal

            // Set cropper canvas dimensions to fit the image while maintaining aspect ratio
            const maxWidth = cropperCanvas.parentElement.clientWidth * 0.9;
            const maxHeight = window.innerHeight * 0.7; // Max 70% of viewport height for cropper image
            
            let imgRatio = originalImage.width / originalImage.height;
            let canvasWidth = originalImage.width;
            let canvasHeight = originalImage.height;

            if (canvasWidth > maxWidth) {
                canvasWidth = maxWidth;
                canvasHeight = canvasWidth / imgRatio;
            }
            if (canvasHeight > maxHeight) {
                canvasHeight = maxHeight;
                canvasWidth = canvasHeight * imgRatio;
            }

            cropperCanvas.width = canvasWidth;
            cropperCanvas.height = canvasHeight;

            // Initialize cropRect to a default square in the center
            const minDim = Math.min(cropperCanvas.width, cropperCanvas.height);
            cropRect.size = minDim * 0.8; // Start with 80% of the smaller dimension
            cropRect.x = (cropperCanvas.width / 2) - (cropRect.size / 2);
            cropRect.y = (cropperCanvas.height / 2) - (cropRect.size / 2);

            drawCropper();

            // Enable buttons
            confirmCropButton.disabled = false;
            cancelCropButton.disabled = false;
        }

        function drawCropper() {
            cropperCtx.clearRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            cropperCtx.drawImage(originalImage, 0, 0, cropperCanvas.width, cropperCanvas.height);

            // Draw overlay (darkened outside cropRect)
            cropperCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            cropperCtx.fillRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            // Draw transparent hole for the crop area
            cropperCtx.globalCompositeOperation = 'destination-out';
            cropperCtx.fillRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);
            cropperCtx.globalCompositeOperation = 'source-over'; // Reset composite operation

            // Draw crop rectangle border
            cropperCtx.strokeStyle = '#fff';
            cropperCtx.lineWidth = 2;
            cropperCtx.strokeRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);

            // Draw resize handles (corners)
            const handleColor = currentTheme === 'dark' ? '#a78bfa' : '#6366f1'; // Violet-400 for dark theme
            cropperCtx.fillStyle = handleColor;
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Top-left
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Top-right
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Bottom-left
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Bottom-right
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) * (canvas.width / rect.width),
                y: (evt.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const touch = evt.touches[0];
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        cropperCanvas.addEventListener('mousedown', handleCropStart);
        cropperCanvas.addEventListener('mousemove', handleCropMove);
        cropperCanvas.addEventListener('mouseup', handleCropEnd);
        cropperCanvas.addEventListener('mouseleave', handleCropEnd); // End drag if mouse leaves canvas

        cropperCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleCropStart(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleCropMove(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchend', handleCropEnd);

        function handleCropStart(e) {
            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            dragStartX = pos.x;
            dragStartY = pos.y;

            // Check if resizing handle is clicked (bottom-right corner)
            if (pos.x > cropRect.x + cropRect.size - resizeHandleSize && pos.x < cropRect.x + cropRect.size + resizeHandleSize &&
                pos.y > cropRect.y + cropRect.size - resizeHandleSize && pos.y < cropRect.y + cropRect.size + resizeHandleSize) {
                isResizing = true;
            } else if (pos.x > cropRect.x && pos.x < cropRect.x + cropRect.size &&
                       pos.y > cropRect.y && pos.y < cropRect.y + cropRect.size) {
                isDragging = true;
            }
        }

        function handleCropMove(e) {
            if (!isDragging && !isResizing) return;

            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;

            if (isDragging) {
                cropRect.x += dx;
                cropRect.y += dy;

                // Keep cropRect within canvas bounds
                cropRect.x = Math.max(0, Math.min(cropRect.x, cropperCanvas.width - cropRect.size));
                cropRect.y = Math.max(0, Math.min(cropRect.y, cropperCanvas.height - cropRect.size));
            } else if (isResizing) {
                let newSize = Math.max(20, cropRect.size + dx); // Minimum size 20px
                newSize = Math.max(newSize, cropRect.size + dy); // Use larger delta for square resize

                // Ensure cropRect stays within canvas bounds during resize
                newSize = Math.min(newSize, cropperCanvas.width - cropRect.x);
                newSize = Math.min(newSize, cropperCanvas.height - cropRect.y);

                cropRect.size = newSize;
            }

            dragStartX = pos.x;
            dragStartY = pos.y;

            drawCropper();
        }

        function handleCropEnd() {
            isDragging = false;
            isResizing = false;
        }

        confirmCropButton.addEventListener('click', async () => { // Added async here
            // Calculate final source dimensions for the original image
            const scaleX = originalImage.width / cropperCanvas.width;
            const scaleY = originalImage.height / cropperCanvas.height;

            finalSourceX = cropRect.x * scaleX;
            finalSourceY = cropRect.y * scaleY;
            finalSourceWidth = cropRect.size * scaleX;
            finalSourceHeight = cropRect.size * scaleY; // Always square, so height = width

            imageCropperContainer.style.display = 'none'; // Hide cropper modal
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            
            initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
            await animateShuffle(); // Auto-shuffle after cropping
            enableAllButtons(); // Re-enable main buttons
        });

        cancelCropButton.addEventListener('click', () => {
            imageCropperContainer.style.display = 'none'; // Hide cropper modal
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            showMessageBox("cropCancelled");
            // Reset to placeholder if no image was previously loaded, or just enable buttons
            if (!puzzleReady) {
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
            }
            enableAllButtons();
        });

        // =====================================================================
        // Move History Functionality
        // =====================================================================
        function addMoveToHistory(pieceNumber, fromIndex, toIndex, currentGridSize) {
            const fromRow = Math.floor(fromIndex / currentGridSize);
            const fromCol = fromIndex % currentGridSize;
            const toRow = Math.floor(toIndex / currentGridSize);
            const toCol = toIndex % currentGridSize;

            let directionKey = '';
            if (fromRow === toRow) { // Horizontal move
                directionKey = fromCol < toCol ? 'directionRight' : 'directionLeft';
            } else { // Vertical move
                directionKey = fromRow < toRow ? 'directionDown' : 'directionUp';
            }

            const moveText = translations[currentLanguage].pieceMoved(pieceNumber, translations[currentLanguage][directionKey]);
            moveHistory.unshift(moveText); // Add to the beginning
            if (moveHistory.length > maxMoveHistory) {
                moveHistory.pop(); // Remove oldest if exceeding limit
            }
            renderMoveHistory();
        }

        function renderMoveHistory() {
            moveHistoryList.innerHTML = '';
            if (moveHistory.length === 0) {
                moveHistoryList.innerHTML = `<li class="text-center text-secondary">${translations[currentLanguage].noMovesYet}</li>`;
                return;
            }
            moveHistory.forEach(move => {
                const listItem = document.createElement('li');
                listItem.textContent = move;
                moveHistoryList.appendChild(listItem);
            });
        }

        // =====================================================================
        // Share Link Functionality (using Base64)
        // =====================================================================
        shareLinkButton.addEventListener('click', () => {
            if (!puzzleReady || !currentBase64Image) {
                showMessageBox("noImageLoaded"); // Or a more specific message like "Please load an image first."
                return;
            }

            const baseUrl = window.location.origin + window.location.pathname;
            const shareUrl = `${baseUrl}?img=${encodeURIComponent(currentBase64Image)}&grid=${gridSize}&mode=${currentPuzzleMode}`;

            // Use Clipboard API if available, fallback to execCommand
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(shareUrl)
                    .then(() => {
                        showMessageBox("shareLinkCopied");
                    })
                    .catch(err => {
                        console.error('Failed to copy: ', err);
                        // Fallback for browsers that don't support Web Share API or if clipboard.writeText fails
                        const tempInput = document.createElement('textarea');
                        tempInput.value = shareUrl;
                        document.body.appendChild(tempInput);
                        tempInput.select();
                        document.execCommand('copy');
                        document.body.removeChild(tempInput);
                        showMessageBox("shareLinkCopied");
                    });
            } else {
                const tempInput = document.createElement('textarea');
                tempInput.value = shareUrl;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                showMessageBox("shareLinkCopied");
            }
        });

        // =====================================================================
        // Progress Indicator Functions
        // =====================================================================
        function updateProgressIndicator() {
            let correctPieces = 0;
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id === currentPieceIndex) {
                    correctPieces++;
                }
            }
            const progressPercentage = Math.floor((correctPieces / totalPieces) * 100);
            progressBar.style.width = `${progressPercentage}%`;
            progressText.textContent = `${progressPercentage}%`;
        }

        // =====================================================================
        // Confetti Animation Functions
        // =====================================================================
        function randomColor() {
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722', '#795548', '#9e9e9e', '#607d8b'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        class ConfettiParticle {
            constructor(x, y, radius, color) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color;
                this.velocity = {
                    x: (Math.random() - 0.5) * 10,
                    y: (Math.random() - 0.5) * 10 - 5 // Upwards initial velocity
                };
                this.alpha = 1;
                this.gravity = 0.3;
                this.friction = 0.99;
            }

            update() {
                this.velocity.x *= this.friction;
                this.velocity.y *= this.friction;
                this.velocity.y += this.gravity;
                this.x += this.velocity.x;
                this.y += this.velocity.y;
                this.alpha -= 0.01; // Fade out
            }

            draw() {
                confettiCtx.save();
                confettiCtx.globalAlpha = this.alpha;
                confettiCtx.beginPath();
                confettiCtx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                confettiCtx.fillStyle = this.color;
                confettiCtx.fill();
                confettiCtx.restore();
            }
        }

        function startConfetti() {
            stopConfetti(); // Ensure no previous animation is running
            confettiParticles = [];
            const numberOfParticles = 100; // Adjust as needed
            const centerX = confettiCanvas.width / 2;
            const centerY = confettiCanvas.height / 2;

            for (let i = 0; i < numberOfParticles; i++) {
                confettiParticles.push(new ConfettiParticle(
                    centerX + (Math.random() - 0.5) * 100, // Spread around center
                    centerY + (Math.random() - 0.5) * 100,
                    Math.random() * 5 + 2, // Radius between 2 and 7
                    randomColor()
                ));
            }

            function animateConfetti() {
                confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
                for (let i = confettiParticles.length - 1; i >= 0; i--) {
                    const particle = confettiParticles[i];
                    particle.update();
                    particle.draw();

                    if (particle.alpha <= 0.1 || particle.y > confettiCanvas.height) {
                        confettiParticles.splice(i, 1); // Remove faded or off-screen particles
                    }
                }

                if (confettiParticles.length > 0) {
                    confettiAnimationId = requestAnimationFrame(animateConfetti);
                } else {
                    stopConfetti(); // Stop animation when all particles are gone
                }
            }
            animateConfetti();
        }

        function stopConfetti() {
            if (confettiAnimationId) {
                cancelAnimationFrame(confettiAnimationId);
                confettiAnimationId = null;
            }
            confettiParticles = [];
            confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        }


        // =====================================================================
        // Initial Page Load Setup (placeholder image or shared link)
        // =====================================================================
        window.onload = async () => {
            loadPreferences(); // Load saved preferences (language and theme)
            loadPlayerStatistics(); // Load saved player stats
            updateTextContent(); // Update text based on loaded language and theme
            updatePlayerStatisticsDisplay(); // Display loaded stats

            const urlParams = new URLSearchParams(window.location.search);
            const imgParam = urlParams.get('img');
            const gridParam = urlParams.get('grid');
            const modeParam = urlParams.get('mode');

            if (imgParam && gridParam && modeParam) {
                showLoading("loadingImage");
                originalImage.onload = async () => {
                    hideLoading();
                    // For shared links, assume the Base64 image is already square (1080x1080)
                    // so we can directly initialize without cropping.
                    initializePuzzle(0, 0, originalImage.width, originalImage.height);
                    await animateShuffle(); // Auto-shuffle after loading from link
                };
                originalImage.onerror = () => {
                    hideLoading();
                    showMessageBox("failedLoadImage");
                    // Fallback to placeholder if shared image fails to load
                    const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                    const placeholderSize = fixedCanvasSize;
                    originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
                    enableAllButtons();
                };

                try {
                    gridSize = parseInt(gridParam);
                    currentPuzzleMode = modeParam;
                    // Update selects to reflect loaded parameters
                    gridSizeSelect.value = gridSize;
                    puzzleModeSelect.value = currentPuzzleMode;
                    originalImage.src = decodeURIComponent(imgParam);
                } catch (e) {
                    console.error("Error parsing URL parameters or Base64 image:", e);
                    showMessageBox("failedLoadImage");
                    // Fallback to placeholder if parsing fails
                    const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                    const placeholderSize = fixedCanvasSize;
                    originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`;
                    enableAllButtons();
                }
            } else {
                originalImage.onload = async () => {
                    // If the image is already square, directly initialize
                    if (originalImage.width === originalImage.height) {
                        initializePuzzle(0, 0, originalImage.width, originalImage.height);
                    } else {
                        // Otherwise, show the cropping interface
                        setupCroppingInterface();
                    }
                };
                const placeholderText = translations[currentLanguage].uploadPhoto.replace(':', '') + `\n(${gridSize}x${gridSize})`;
                const placeholderSize = fixedCanvasSize; 
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=${encodeURIComponent(placeholderText)}`; 
            }
        };

    </script>
</body>
</html>
