<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta name="keywords" content="sliding puzzle, puzzle geser, game puzzle, puzzle foto, game online, puzzle interaktif, potong gambar, gratis">
    <meta name="author" content="hanzercopy.cloud">
    
    <!-- Open Graph / Facebook / LinkedIn -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://hanzercopy.cloud">
    <meta property="og:title" content="Sliding Puzzle Interaktif - Mainkan Puzzle Foto Anda!">
    <meta property="og:description" content="Mainkan game sliding puzzle interaktif dengan foto Anda sendiri atau gambar contoh. Potong gambar sesuai keinginan Anda dan tantang diri Anda dengan berbagai ukuran grid.">
    <meta property="og:image" content="https://placehold.co/1200x630/e0e7ff/4f46e5?text=Sliding%20Puzzle"> <!-- Ganti dengan URL gambar pratinjau Anda -->

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Menggunakan font Inter dari Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif';
            /* Latar belakang gradient modern */
            background-image: linear-gradient(to bottom right, #a78bfa, #818cf8, #6366f1); /* Ungu-biru gradient */
            background-attachment: fixed; /* Memastikan gradient tetap saat scroll */
            overflow-x: hidden; /* Mencegah overflow horizontal */
        }
        /* Styling untuk canvas */
        canvas {
            display: block; /* Menghilangkan spasi ekstra di bawah canvas */
            background-color: #ffffff; /* Latar belakang canvas putih bersih */
            border: 3px solid #4f46e5; /* Border ungu tua (indigo-600) */
            border-radius: 0.75rem; /* Sudut membulat */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            touch-action: manipulation; /* Memungkinkan event sentuhan */
            -webkit-user-select: none; /* Non-seleksi teks untuk iOS */
            -moz-user-select: none; /* Non-seleksi teks untuk Firefox */
            -ms-user-select: none; /* Non-seleksi teks untuk IE/Edge */
            user-select: none; /* Non-seleksi teks */
            /* Transisi untuk animasi kemenangan */
            transition: transform 0.5s ease-out, border 0.5s ease-out, box-shadow 0.5s ease-out;
        }
        .message-box, .confirmation-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            z-index: 1000;
            text-align: center;
            border: 2px solid #4f46e5; /* Border ungu tua */
            width: 90%;
            max-width: 400px;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        /* Styling untuk tombol */
        .btn-primary-gradient {
            background-image: linear-gradient(to right, #6366f1, #8b5cf6); /* Indigo ke Violet */
            transition: background-image 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-primary-gradient:hover {
            background-image: linear-gradient(to right, #4f46e5, #7c3aed); /* Lebih gelap saat hover */
        }
        .btn-primary-gradient:active {
            background-image: linear-gradient(to right, #3730a3, #5b21b6); /* Lebih gelap lagi saat ditekan */
            transform: scale(0.98);
        }

        .btn-purple {
            background-color: #a855f7; /* Purple-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-purple:hover {
            background-color: #9333ea; /* Purple-600 */
        }
        .btn-purple:active {
            background-color: #7e22ce; /* Purple-700 saat ditekan */
            transform: scale(0.98);
        }

        .btn-green-solve {
            background-color: #10b981; /* Green-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-green-solve:hover {
            background-color: #059669;
        }
        .btn-green-solve:active {
            background-color: #047857;
            transform: scale(0.98);
        }

        .btn-gray { /* General gray button for Reset */
            background-color: #6b7280; /* Gray-500 */
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .btn-gray:hover {
            background-color: #4b5563; /* Gray-600 */
        }
        .btn-gray:active {
            background-color: #374151; /* Gray-700 saat ditekan */
            transform: scale(0.98);
        }

        /* Styling untuk gambar contoh yang bisa diklik */
        .sample-image-container {
            width: 80px; /* Lebar tetap untuk gambar contoh */
            height: 80px; /* Tinggi tetap untuk gambar contoh */
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            cursor: pointer;
            transition: transform 0.2s ease-in-out, border 0.2s ease-in-out;
            border: 2px solid transparent; /* Border transparan default */
        }
        .sample-image-container:hover {
            transform: scale(1.05); /* Sedikit membesar saat hover */
            border-color: #6366f1; /* Warna border saat hover */
        }
        .sample-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Pastikan gambar mengisi container tanpa distorsi */
            display: block;
        }


        /* Kelas untuk animasi kemenangan */
        .puzzle-solved-animation {
            animation: puzzle-bounce 0.5s ease-out forwards;
            border-color: #10b981; /* Green-500 for solved state */
            box-shadow: 0 0 20px 5px rgba(16, 185, 129, 0.7), 0 0 30px 10px rgba(16, 185, 129, 0.5); /* Glowing effect */
        }

        @keyframes puzzle-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.03); }
            100% { transform: scale(1); }
        }

        /* Container untuk tampilan gambar asli di bawah */
        .original-image-display-container {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            padding: 1.5rem;
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 3xl; /* Match main container width */
        }
        .original-image-display-container.show {
            display: flex;
        }
        .original-image-display-container img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            margin-bottom: 1.5rem;
        }
        .original-image-display-container button {
            margin-top: 0; /* Adjust margin if needed */
        }

        /* Kelas untuk menyembunyikan main-content saat gambar asli ditampilkan */
        .main-content-hidden {
            display: none;
        }

        /* Cropper Modal Styling */
        .cropper-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        .cropper-content {
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        #cropperCanvas {
            border: 2px solid #6366f1;
            background-color: #f0f0f0;
            max-width: 100%;
            max-height: 60vh; /* Adjust as needed */
            display: block;
        }
        .cropper-controls {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1002;
            display: none; /* Hidden by default */
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Move History Styling */
        #moveHistoryContainer {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 0.75rem;
            background-color: #f8fafc;
            font-size: 0.875rem;
            line-height: 1.5;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4 text-gray-900">

    <div id="mainContent" class="w-full max-w-3xl bg-white p-6 rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-center text-indigo-700 mb-6">Sliding Puzzle Interaktif</h1>

        <!-- Potensi Area Iklan (Contoh: Banner Atas) -->
        <!-- <div class="w-full h-20 bg-gray-200 flex items-center justify-center text-gray-600 mb-6 rounded-lg">
            AREA IKLAN (728x90)
        </div> -->

        <div class="mb-6">
            <label for="imageUpload" class="block text-lg font-medium text-gray-700 mb-2">Unggah Foto Anda:</label>
            <input type="file" id="imageUpload" accept="image/*" class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
        </div>

        <div class="mb-6 text-center">
            <label class="block text-lg font-medium text-gray-700 mb-2">Atau Pilih Gambar Contoh:</label>
            <div id="sampleImageContainer" class="flex flex-wrap justify-center gap-2">
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/1.png" alt="Contoh Gambar 1" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/2.png" alt="Contoh Gambar 2" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/3.png" alt="Contoh Gambar 3" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
                <div class="sample-image-container" data-src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png">
                    <img src="https://raw.githubusercontent.com/SapiBersinar/data/main/gambar/4.png" alt="Contoh Gambar 4" onerror="this.onerror=null;this.src='https://placehold.co/80x80/cccccc/333333?text=Error';">
                </div>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <div class="text-center">
                <label for="gridSizeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Ukuran Puzzle:</label>
                <select id="gridSizeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                    <option value="3" selected>3x3</option>
                    <option value="4">4x4</option>
                    <option value="5">5x5</option>
                </select>
            </div>

            <div class="text-center">
                <label for="puzzleModeSelect" class="block text-lg font-medium text-gray-700 mb-2">Pilih Mode Puzzle:</label>
                <select id="puzzleModeSelect" class="px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-transparent">
                    <option value="sliding" selected>Sliding Puzzle (Default)</option>
                    <option value="jigsaw">Jigsaw (Tanpa Nomor)</option>
                </select>
            </div>
        </div>
        
        <div class="flex justify-center gap-8 mb-4 text-center">
            <div class="text-lg font-semibold text-gray-700">
                Gerakan: <span id="moveCounter" class="text-indigo-700">0</span>
            </div>
            <div class="text-lg font-semibold text-gray-700">
                Waktu: <span id="timerDisplay" class="text-indigo-700">00:00</span>
            </div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button id="shuffleButton" class="btn-primary-gradient text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">
                Acak
            </button>
            <button id="undoButton" class="btn-purple text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-purple-400 focus:ring-offset-2">
                Urungkan
            </button>
            <button id="solveButton" class="btn-green-solve text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">
                Selesaikan Otomatis
            </button>
            <button id="resetButton" class="btn-gray text-white font-semibold py-3 px-6 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Reset Puzzle
            </button>
        </div>
        <div id="solveStatus" class="text-center text-red-600 font-medium mb-4" style="min-height: 24px;"></div>


        <div class="relative w-full max-w-full flex justify-center items-center overflow-hidden mb-6" style="min-height: 250px;">
            <canvas id="puzzleCanvas" class="w-full h-auto max-w-full"></canvas>
        </div>

        <div class="text-center mt-4 flex flex-wrap justify-center gap-4">
            <button id="viewOriginalImageButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2">
                Lihat Gambar Asli
            </button>
            <button id="replayButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" style="display: none;">
                Putar Ulang Gerakan
            </button>
        </div>
        
        <p class="text-center text-gray-600 text-sm italic mt-4">Klik potongan yang berdekatan dengan tempat kosong untuk memindahkannya.</p>

        <div class="mt-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-2 text-center">Riwayat Gerakan Anda:</h2>
            <div id="moveHistoryContainer" class="bg-gray-50 p-3 rounded-lg shadow-inner">
                <ul id="moveHistoryList" class="list-disc list-inside text-gray-700">
                    <!-- Move history items will be appended here -->
                </ul>
            </div>
        </div>

        <!-- Potensi Area Iklan (Contoh: Banner Bawah) -->
        <!-- <div class="w-full h-20 bg-gray-200 flex items-center justify-center text-gray-600 mt-6 rounded-lg">
            AREA IKLAN (728x90)
        </div> -->
        
    </div>

    <div id="messageBoxContainer"></div>
    <div id="confirmationBoxContainer"></div>

    <div id="originalImageDisplayContainer" class="original-image-display-container">
        <img id="fullImageDisplay" src="" alt="Gambar Asli">
        <button id="backToPuzzleButton" class="btn-primary-gradient text-white font-semibold py-2 px-4 rounded-lg shadow-md">
            Kembali ke Puzzle
        </button>
    </div>

    <!-- Cropper Modal -->
    <div id="imageCropperContainer" class="cropper-modal" style="display: none;">
        <div class="cropper-content">
            <h2 class="text-2xl font-bold text-center text-indigo-700 mb-4">Pilih Area Puzzle</h2>
            <canvas id="cropperCanvas"></canvas>
            <div class="cropper-controls">
                <button id="confirmCropButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-lg shadow-md">
                    Konfirmasi Potongan
                </button>
                <button id="cancelCropButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-lg shadow-md">
                    Batal
                </button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="spinner"></div>
        <p id="loadingMessage">Memuat...</p>
    </div>


    <script type="module">
        const imageUpload = document.getElementById('imageUpload');
        const gridSizeSelect = document.getElementById('gridSizeSelect');
        const puzzleModeSelect = document.getElementById('puzzleModeSelect');
        // const languageSelect = document.getElementById('languageSelect'); // Removed
        const shuffleButton = document.getElementById('shuffleButton');
        const undoButton = document.getElementById('undoButton');
        const solveButton = document.getElementById('solveButton');
        const resetButton = document.getElementById('resetButton');
        const puzzleCanvas = document.getElementById('puzzleCanvas');
        const ctx = puzzleCanvas.getContext('2d');
        const messageBoxContainer = document.getElementById('messageBoxContainer');
        const confirmationBoxContainer = document.getElementById('confirmationBoxContainer');
        const moveCounterDisplay = document.getElementById('moveCounter');
        const timerDisplay = document.getElementById('timerDisplay');
        const solveStatusDisplay = document.getElementById('solveStatus');
        const viewOriginalImageButton = document.getElementById('viewOriginalImageButton');
        const originalImageDisplayContainer = document.getElementById('originalImageDisplayContainer');
        const fullImageDisplay = document.getElementById('fullImageDisplay');
        const backToPuzzleButton = document.getElementById('backToPuzzleButton');
        const mainContent = document.getElementById('mainContent');
        const replayButton = document.getElementById('replayButton');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const moveHistoryList = document.getElementById('moveHistoryList');

        // Cropper elements
        const imageCropperContainer = document.getElementById('imageCropperContainer');
        const cropperCanvas = document.getElementById('cropperCanvas');
        const cropperCtx = cropperCanvas.getContext('2d');
        const confirmCropButton = document.getElementById('confirmCropButton');
        const cancelCropButton = document.getElementById('cancelCropButton');

        // Sample image elements
        const sampleImageContainers = document.querySelectorAll('.sample-image-container');
        let originalImage = new Image();
        let puzzlePieces = [];
        let gridSize = parseInt(gridSizeSelect.value);
        let currentPuzzleMode = puzzleModeSelect.value;
        const fixedCanvasSize = 1080; // Fixed to 1080x1080
        let pieceWidth;
        let pieceHeight;
        let blankPieceIndex;
        let isShuffled = false;
        let puzzleReady = false;
        let moves = 0;
        let isProcessingClick = false; // Flag for manual click animation
        let solving = false; // Flag for auto-solve process
        let shuffling = false; // Flag for initial shuffle animation
        let undoStack = [];
        const maxUndoStates = 50;

        let startTime;
        let timerInterval;
        let hasMadeFirstMove = false; // New flag for timer start
        const animationDuration = 200; // Manual move animation duration (ms)
        
        // Dynamic shuffle animation parameters
        const getShuffleParams = (gridSize) => {
            switch (gridSize) {
                case 3: return { numMoves: 220, visualDelay: 16 }; // ~3.5s total (220 * 16ms)
                case 4: return { numMoves: 240, visualDelay: 17 }; // ~4s total (240 * 17ms)
                case 5: return { numMoves: 500, visualDelay: 10 }; // ~5s total (500 * 10ms)
                default: return { numMoves: 220, visualDelay: 16 };
            }
        };

        // Delay per gerakan untuk auto-solve, tergantung ukuran grid
        const getAutoSolveStepDelay = (gridSize) => {
            if (gridSize === 3 || gridSize === 4) return 150; // 0.15 seconds for smoother auto-solve
            if (gridSize === 5) return 350; // 0.35 seconds
            return 150; // Default
        };
        
        const maxStatesToExploreForBFS = 1000000;

        // Cropping variables
        let cropRect = { x: 0, y: 0, size: 0 }; // x, y, width/height of the square crop area
        let isDragging = false;
        let isResizing = false;
        let dragStartX, dragStartY;
        const resizeHandleSize = 10; // Size of the draggable corner for resizing

        // Source dimensions for puzzle pieces after cropping
        let finalSourceX = 0;
        let finalSourceY = 0;
        let finalSourceWidth = 0;
        let finalSourceHeight = 0;

        // Replay variables
        let replayMoves = []; // Stores { pieceId, fromIndex, toIndex } for each move
        let initialShuffledStateForReplay = []; // Stores the piece configuration right after shuffling
        let isReplaying = false; // New flag for replay mode

        let moveHistory = [];
        const maxMoveHistory = 10;


        // =====================================================================
        // Utility function for notifications (replaces alert())
        // =====================================================================
        function showMessageBox(message) {
            const messageBox = document.createElement('div');
            messageBox.className = 'message-box';
            messageBox.innerHTML = `
                <p class="text-xl font-semibold mb-4">${message}</p>
                <button id="closeMessageBox" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition duration-300">Oke</button>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            messageBoxContainer.appendChild(overlay);
            messageBoxContainer.appendChild(messageBox);

            document.getElementById('closeMessageBox').onclick = () => {
                messageBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Custom Confirmation Box
        // =====================================================================
        function showConfirmationBox(message, onConfirmCallback) {
            const confirmationBox = document.createElement('div');
            confirmationBox.className = 'confirmation-box';
            confirmationBox.innerHTML = `
                <p class="text-xl font-semibold mb-6">${message}</p>
                <div class="flex justify-center gap-4">
                    <button id="confirmButton" class="btn-green-solve text-white font-semibold py-2 px-4 rounded-md transition duration-300">Ya</button>
                    <button id="cancelButton" class="btn-gray text-white font-semibold py-2 px-4 rounded-md transition duration-300">Batal</button>
                </div>
            `;
            const overlay = document.createElement('div');
            overlay.className = 'overlay';

            confirmationBoxContainer.appendChild(overlay);
            confirmationBoxContainer.appendChild(confirmationBox);

            document.getElementById('confirmButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
                onConfirmCallback();
            };
            document.getElementById('cancelButton').onclick = () => {
                confirmationBoxContainer.innerHTML = '';
            };
        }

        // =====================================================================
        // Loading Indicator Functions
        // =====================================================================
        function showLoading(message) {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        // =====================================================================
        // Function to check puzzle solvability
        // =====================================================================
        function isPuzzleSolvable(piecesArray, currentGridSize) {
            // Get the current order of original IDs of pieces
            const currentOrder = Array(currentGridSize * currentGridSize).fill(0);
            const piecePositions = new Map(); // Map originalId to current index in 1D array
            
            piecesArray.forEach(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                const index = row * currentGridSize + col;
                currentOrder[index] = p.id;
                piecePositions.set(p.id, index);
            });
            // Find the blank piece and its row (0-indexed from top)
            const blankPiece = piecesArray.find(p => p.isBlank);
            const blankIndex = piecePositions.get(blankPiece.id);
            const blankRowFromTop = Math.floor(blankIndex / currentGridSize);
            // Create a 1D array of non-blank piece IDs in their current reading order
            const flatState = currentOrder.filter(id => id !== blankPiece.id);
            let inversions = 0;
            for (let i = 0; i < flatState.length - 1; i++) {
                for (let j = i + 1; j < flatState.length; j++) {
                    if (flatState[i] > flatState[j]) {
                        inversions++;
                    }
                }
            }

            // Solvability rules based on grid size and blank tile position
            if (currentGridSize % 2 === 1) { // Odd grid size
                return inversions % 2 === 0;
            } else { // Even grid size
                const blankRowFromBottom = currentGridSize - blankRowFromTop; // 1-indexed from bottom
                if (blankRowFromBottom % 2 === 1) { // Blank on an odd row from bottom
                    return inversions % 2 === 0;
                } else { // Blank on an even row from bottom
                    return inversions % 2 === 1;
                }
            }
        }


        // =====================================================================
        // Handle Image Upload
        // =====================================================================
        imageUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                showLoading("Memuat gambar...");
                const reader = new FileReader();
                reader.onload = (e) => {
                    originalImage.onload = () => {
                        hideLoading();
                        // Check if image is already 1:1 aspect ratio
                        if (originalImage.width === originalImage.height) {
                            initializePuzzle(0, 0, originalImage.width, originalImage.height); // Use full image
                            animateShuffle();
                        } else {
                            setupCroppingInterface(); // Show cropper for non-square images
                        }
                    };
                    originalImage.onerror = () => {
                        hideLoading();
                        showMessageBox("Gagal memuat gambar. Pastikan ini adalah file gambar yang valid.");
                        enableAllButtons();
                    };
                    originalImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        // =====================================================================
        // Handle Sample Image Selection
        // =====================================================================
        sampleImageContainers.forEach(container => {
            container.addEventListener('click', async (event) => {
                const imageUrl = container.dataset.src;
                if (!imageUrl) return;

                if (shuffling || solving || isProcessingClick || isReplaying) return; // Disable during replay

                showLoading("Memuat gambar contoh...");
                disableAllButtons(); // Disable main buttons while loading/cropping

                originalImage.onload = () => {
                    hideLoading();
                    // Check if image is already 1:1 aspect ratio
                    if (originalImage.width === originalImage.height) {
                        initializePuzzle(0, 0, originalImage.width, originalImage.height); // Use full image
                        animateShuffle();
                    } else {
                        setupCroppingInterface(); // Show cropper for non-square images
                    }
                };
                originalImage.onerror = () => {
                    hideLoading();
                    showMessageBox("Gagal memuat gambar contoh. Silakan coba lagi atau unggah gambar Anda sendiri.");
                    enableAllButtons();
                };
                originalImage.src = imageUrl;
            });
        });


        // =====================================================================
        // Handle Grid Size and Puzzle Mode Changes (with Local Storage)
        // =====================================================================
        gridSizeSelect.addEventListener('change', async (event) => {
            gridSize = parseInt(event.target.value);
            savePreferences(); // Save preference
            if (puzzleReady) {
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
            }
        });

        puzzleModeSelect.addEventListener('change', async (event) => {
            currentPuzzleMode = event.target.value;
            savePreferences(); // Save preference
            if (puzzleReady) {
                initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                await animateShuffle();
            } else {
                drawPuzzle();
            }
        });

        // =====================================================================
        // Initialize Puzzle (Adapts image to 1:1, sets up pieces)
        // =====================================================================
        function initializePuzzle(srcX, srcY, srcW, srcH) {
            finalSourceX = srcX;
            finalSourceY = srcY;
            finalSourceWidth = srcW;
            finalSourceHeight = srcH;

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;

            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            puzzlePieces = [];
            const totalPieces = gridSize * gridSize;
            for (let i = 0; i < totalPieces; i++) {
                puzzlePieces.push({
                    id: i,
                    originalIndex: i, // Store original index to sort back to solved state
                    currentX: (i % gridSize) * pieceWidth,
                    currentY: Math.floor(i / gridSize) * pieceHeight,
                    sourceX: srcX + (srcW / gridSize) * (i % gridSize),
                    sourceY: srcY + (srcH / gridSize) * Math.floor(i / gridSize),
                    sourceWidth: srcW / gridSize,
                    sourceHeight: srcH / gridSize,
                    isBlank: false
                });
            }
            blankPieceIndex = totalPieces - 1;
            puzzlePieces[blankPieceIndex].isBlank = true;
            isShuffled = false; 
            moves = 0;
            undoStack = [];
            replayMoves = []; // Reset replay moves
            initialShuffledStateForReplay = []; // Reset initial state for replay
            replayButton.style.display = 'none'; // Hide replay button
            moveHistory = []; // Reset move history
            renderMoveHistory(); // Update UI
            updateMoveCounter();
            stopTimer(); // Ensure timer is stopped
            timerDisplay.textContent = '00:00';
            hasMadeFirstMove = false; // Reset first move flag for timer
            drawPuzzle(); // Draw in solved state

            puzzleCanvas.classList.remove('puzzle-solved-animation');
            solveStatusDisplay.textContent = '';
            puzzleReady = true;
        }

        // =====================================================================
        // Recalculate piece positions and redraw (used for resize without resetting state)
        // =====================================================================
        function recalculatePiecePositionsAndRedraw() {
            if (!puzzleReady) return; // Only recalculate if puzzle is initialized

            puzzleCanvas.width = fixedCanvasSize;
            puzzleCanvas.height = fixedCanvasSize;
            pieceWidth = puzzleCanvas.width / gridSize;
            pieceHeight = puzzleCanvas.height / gridSize;

            // Re-assign currentX/currentY for each piece based on its *current index in the puzzlePieces array*
            // This preserves the current (shuffled or solved) arrangement
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });

            drawPuzzle();
        }

        // =====================================================================
        // Draw Puzzle on Canvas
        // =====================================================================
        function drawPuzzle() {
            ctx.clearRect(0, 0, puzzleCanvas.width, puzzleCanvas.height);
            puzzlePieces.forEach(piece => {
                if (!piece.isBlank) {
                    ctx.drawImage(
                        originalImage,
                        piece.sourceX, piece.sourceY,
                        piece.sourceWidth, piece.sourceHeight,
                        piece.currentX, piece.currentY,
                        pieceWidth, pieceHeight
                    );

                    // Draw border around pieces
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);

                    // Draw numbers only if not in Jigsaw mode
                    if (currentPuzzleMode === 'sliding') {
                        ctx.fillStyle = '#312e81';
                        ctx.font = `${Math.min(pieceWidth, pieceHeight) * 0.3}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(
                            piece.id + 1,
                            piece.currentX + pieceWidth / 2,
                            piece.currentY + pieceHeight / 2
                        );
                    }
                } else {
                    // Blank piece styling
                    ctx.fillStyle = '#e0e7ff';
                    ctx.fillRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                    ctx.strokeStyle = '#6366f1';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
                }
            });
        }

        // =====================================================================
        // Shuffle Puzzle with visual animation and ensure solvability
        // =====================================================================
        async function animateShuffle() {
            if (!puzzleReady || shuffling || solving || isReplaying) { // Disable during replay
                return;
            }
            shuffling = true;
            showLoading("Mengacak puzzle...");
            disableAllButtons();
            solveStatusDisplay.textContent = 'Mengacak puzzle...';
            const originalBlankId = gridSize * gridSize - 1; // ID of the blank piece
            const { numMoves, visualDelay } = getShuffleParams(gridSize);
            const shuffleStartTime = Date.now();
            let currentSolvable = false;
            let shuffleAttempts = 0;
            const maxShuffleAttempts = 10; // Limit attempts for re-shuffling to find a solvable one

            let finalPuzzleOrder = null; // To store the *logical* order of piece IDs for the solvable state

            while (!currentSolvable && shuffleAttempts < maxShuffleAttempts) {
                // Reset puzzlePieces to the solved state (logically and visually) for this attempt's animation
                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                    piece.isBlank = (piece.id === originalBlankId);
                });
                drawPuzzle(); // Ensure it starts from solved for each attempt

                // Perform the visual shuffle animation for `numMoves`
                let currentVisualPieces = puzzlePieces.map(p => ({ ...p })); // Deep copy for animation state
                let currentVisualBlankPiece = currentVisualPieces.find(p => p.isBlank);
                for (let i = 0; i < numMoves; i++) {
                    if (!shuffling) { // Check if shuffle was externally stopped
                        break;
                    }

                    const blankCol = Math.round(currentVisualBlankPiece.currentX / pieceWidth);
                    const blankRow = Math.round(currentVisualBlankPiece.currentY / pieceHeight);

                    const possibleMoves = [];
                    if (blankRow > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow - 1));
                    if (blankRow < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol && Math.round(p.currentY / pieceHeight) === blankRow + 1));
                    if (blankCol > 0) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol - 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    if (blankCol < gridSize - 1) possibleMoves.push(currentVisualPieces.find(p => Math.round(p.currentX / pieceWidth) === blankCol + 1 && Math.round(p.currentY / pieceHeight) === blankRow));
                    const validMoves = possibleMoves.filter(p => p && !p.isBlank);

                    if (validMoves.length === 0) continue;

                    const pieceToMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                    // Perform the swap of visual coordinates on `currentVisualPieces`
                    const tempX = pieceToMove.currentX;
                    const tempY = pieceToMove.currentY;

                    pieceToMove.currentX = currentVisualBlankPiece.currentX;
                    pieceToMove.currentY = currentVisualBlankPiece.currentY;

                    currentVisualBlankPiece.currentX = tempX;
                    currentVisualBlankPiece.currentY = tempY;
                    // Update the array order of `currentVisualPieces` to reflect the new visual positions
                    const pieceToMoveIndexInArray = currentVisualPieces.indexOf(pieceToMove);
                    const blankIndexInArray = currentVisualPieces.indexOf(currentVisualBlankPiece);
                    [currentVisualPieces[pieceToMoveIndexInArray], currentVisualPieces[blankIndexInArray]] = 
                    [currentVisualPieces[blankIndexInArray], currentVisualPieces[pieceToMoveIndexInArray]];
                    // Temporarily assign currentVisualPieces to puzzlePieces for drawing
                    puzzlePieces = currentVisualPieces;
                    drawPuzzle(); // Redraw after each step
                    await new Promise(resolve => setTimeout(resolve, visualDelay));
                }

                // After the visual animation, check if the resulting state is solvable
                if (isPuzzleSolvable(puzzlePieces, gridSize)) {
                    currentSolvable = true;
                    finalPuzzleOrder = puzzlePieces.map(p => p.id); // Store the IDs order of this solvable state
                } else {
                    shuffleAttempts++;
                    // If not solvable, the loop will restart, re-initializing and re-animating
                    console.warn(`Attempt ${shuffleAttempts}: Shuffled puzzle is not solvable. Retrying...`);
                }
            } // End of while loop (attempting to find a solvable animated shuffle)

            hideLoading();

            if (!shuffling) { // If shuffle was cancelled during animation
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                enableAllButtons();
                return;
            }

            if (currentSolvable && finalPuzzleOrder) {
                // Ensure `puzzlePieces` is exactly the solvable state found, even if visual steps deviated slightly
                let correctedPuzzlePieces = [];
                for (let i = 0; i < finalPuzzleOrder.length; i++) {
                    const pieceId = finalPuzzleOrder[i];
                    const originalPieceData = puzzlePieces.find(p => p.id === pieceId);
                    correctedPuzzlePieces.push({
                        ...originalPieceData,
                        currentX: (i % gridSize) * pieceWidth,
                        currentY: Math.floor(i / gridSize) * pieceHeight,
                        isBlank: (pieceId === originalBlankId)
                    });
                }
                puzzlePieces = correctedPuzzlePieces;
                drawPuzzle(); // Final draw to the guaranteed solvable state

                const shuffleEndTime = Date.now();
                const elapsedTimeSeconds = ((shuffleEndTime - shuffleStartTime) / 1000).toFixed(2);

                isShuffled = true;
                moves = 0;
                undoStack = [];
                replayMoves = []; // Clear replay moves for a fresh game
                initialShuffledStateForReplay = puzzlePieces.map(p => ({ ...p })); // Store initial state for replay
                replayButton.style.display = 'none'; // Hide replay button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI
                updateMoveCounter();
                hasMadeFirstMove = false; // Reset for timer to start on first user move
                
                shuffling = false;
                enableAllButtons();

                solveStatusDisplay.textContent = `Berhasil mengacak ${numMoves} gerakan dalam ${elapsedTimeSeconds} detik.`;
                
            } else {
                shuffling = false;
                enableAllButtons();
                solveStatusDisplay.textContent = `Gagal menemukan puzzle yang dapat dipecahkan setelah ${maxShuffleAttempts} percobaan. Coba acak ulang.`;
                showMessageBox("Gagal menemukan puzzle yang dapat dipecahkan setelah beberapa kali percobaan. Harap coba lagi atau unggah gambar yang berbeda.");
                // Revert to initial state if cropping was done
                if (finalSourceWidth > 0 && finalSourceHeight > 0) {
                    initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
                } else {
                    // If no image was properly loaded/cropped, show placeholder
                    const placeholderSize = fixedCanvasSize;
                    originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
                }
            }
        }


        shuffleButton.addEventListener('click', animateShuffle);
        // =====================================================================
        // Undo Puzzle Move
        // =====================================================================
        undoButton.addEventListener('click', () => {
            if (isProcessingClick || solving || shuffling || isReplaying) return; // Disable during replay

            if (undoStack.length > 0) {
                const prevState = undoStack.pop();
                puzzlePieces = prevState.pieces.map(p => ({ ...p }));
                moves = prevState.moves;
                isShuffled = prevState.isShuffled;
                currentPuzzleMode = prevState.puzzleMode;

                // Re-calculate positions based on the restored array order
                puzzlePieces.forEach((piece, index) => {
                    piece.currentX = (index % gridSize) * pieceWidth;
                    piece.currentY = Math.floor(index / gridSize) * pieceHeight;
                });

                // Remove the last move from replay history as well
                if (replayMoves.length > 0) {
                    replayMoves.pop();
                }
                moveHistory.pop(); // Remove last move from history
                renderMoveHistory(); // Update UI

                updateMoveCounter();
                drawPuzzle();
                puzzleModeSelect.value = currentPuzzleMode;
            } else {
                showMessageBox("Tidak ada gerakan untuk di-undo.");
            }
        });

        // =====================================================================
        // Reset Puzzle to Original Order
        // =====================================================================
        resetButton.addEventListener('click', () => {
            if (isReplaying) return; // Disable during replay

            showConfirmationBox("Apakah Anda yakin ingin mereset puzzle? Progres Anda akan hilang.", () => {
                if (!puzzleReady) {
                    showMessageBox("Silakan unggah gambar terlebih dahulu.");
                    return;
                }

                solving = false;
                shuffling = false;

                puzzlePieces.sort((a, b) => a.originalIndex - b.originalIndex);

                puzzlePieces.forEach((piece, index) => {
                    const targetCol = index % gridSize;
                    const targetRow = Math.floor(index / gridSize);
                    piece.currentX = targetCol * pieceWidth;
                    piece.currentY = targetRow * pieceHeight;
                });

                isShuffled = false;
                moves = 0;
                undoStack = [];
                replayMoves = []; // Reset replay moves
                initialShuffledStateForReplay = []; // Reset initial state for replay
                replayButton.style.display = 'none'; // Hide replay button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI
                updateMoveCounter();
                stopTimer();
                timerDisplay.textContent = '00:00';
                hasMadeFirstMove = false; // Reset first move flag
                drawPuzzle();
                puzzleCanvas.classList.remove('puzzle-solved-animation');
                solveStatusDisplay.textContent = '';

                enableAllButtons();
            });
        });


        // =====================================================================
        // Handle Puzzle Click/Touch (to move pieces)
        // =====================================================================
        puzzleCanvas.addEventListener('click', (event) => {
            if (!puzzleReady || !isShuffled || isProcessingClick || solving || shuffling || isReplaying) { // Disable during replay
                return;
            }
            isProcessingClick = true;

            // Start timer on first move
            if (!hasMadeFirstMove) {
                hasMadeFirstMove = true;
                startTimer();
            }

            const rect = puzzleCanvas.getBoundingClientRect();
            const scaleX = puzzleCanvas.width / rect.width;
            const scaleY = puzzleCanvas.height / rect.height;

            const mouseX = (event.clientX - rect.left) * scaleX;
            const mouseY = (event.clientY - rect.top) * scaleY;

            const clickedCol = Math.floor(mouseX / pieceWidth);
            const clickedRow = Math.floor(mouseY / pieceHeight);
            
            const clickedPiece = puzzlePieces.find(p => 
                Math.abs(p.currentX - (clickedCol * pieceWidth)) < 1 && 
                Math.abs(p.currentY - (clickedRow * pieceHeight)) < 1
            );
            if (!clickedPiece || clickedPiece.isBlank) {
                isProcessingClick = false;
                return;
            }

            const blankPiece = puzzlePieces.find(p => p.isBlank);
            const clickedPieceCol = Math.round(clickedPiece.currentX / pieceWidth);
            const clickedPieceRow = Math.round(clickedPiece.currentY / pieceHeight);
            const blankPieceCol = Math.round(blankPiece.currentX / pieceWidth);
            const blankPieceRow = Math.round(blankPiece.currentY / pieceHeight);

            const isAdjacent = (
                (Math.abs(clickedPieceCol - blankPieceCol) === 1 && clickedPieceRow === blankPieceRow) ||
                (Math.abs(clickedPieceRow - blankPieceRow) === 1 && clickedPieceCol === blankPieceCol)
            );
            if (isAdjacent) {
                const currentStatePieces = puzzlePieces.map(p => ({ ...p }));
                undoStack.push({ pieces: currentStatePieces, moves: moves, isShuffled: isShuffled, puzzleMode: currentPuzzleMode });
                if (undoStack.length > maxUndoStates) {
                    undoStack.shift();
                }

                const targetXForClicked = blankPiece.currentX;
                const targetYForClicked = blankPiece.currentY;
                const targetXForBlank = clickedPiece.currentX;
                const targetYForBlank = clickedPiece.currentY;

                // Record move for replay
                const fromIndex = clickedPieceRow * gridSize + clickedCol;
                const toIndex = blankPieceRow * gridSize + blankPieceCol;
                replayMoves.push({ pieceId: clickedPiece.id, fromIndex: fromIndex, toIndex: toIndex });
                addMoveToHistory(clickedPiece.id + 1, fromIndex, toIndex, gridSize); // Add to move history

                animatePieceMove(
                    clickedPiece, targetXForClicked, targetYForClicked,
                    blankPiece, targetXForBlank, targetYForBlank,
                    () => {
                        clickedPiece.currentX = targetXForClicked;
                        clickedPiece.currentY = targetYForClicked;
                        blankPiece.currentX = targetXForBlank;
                        blankPiece.currentY = targetYForBlank;

                        const clickedIndexInArray = puzzlePieces.indexOf(clickedPiece);
                        const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                        [puzzlePieces[clickedIndexInArray], puzzlePieces[blankIndexInArray]] = 
                        [puzzlePieces[blankIndexInArray], puzzlePieces[clickedIndexInArray]];

                        moves++;
                        updateMoveCounter();
                        drawPuzzle();
                        checkWin();
                        isProcessingClick = false;
                    }
                );
            } else {
                isProcessingClick = false;
            }
        });

        // =====================================================================
        // Piece Movement Animation Function (for manual & auto-solve moves)
        // =====================================================================
        function animatePieceMove(piece1, targetX1, targetY1, piece2, targetX2, targetY2, callback) {
            const startX1 = piece1.currentX;
            const startY1 = piece1.currentY;
            const startX2 = piece2.currentX;
            const startY2 = piece2.currentY;

            let startTime = null;
            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / animationDuration, 1);
                piece1.currentX = startX1 + (targetX1 - startX1) * progress;
                piece1.currentY = startY1 + (targetY1 - startY1) * progress;
                piece2.currentX = startX2 + (targetX2 - startX2) * progress;
                piece2.currentY = startY2 + (targetY2 - startY2) * progress;
                
                drawPuzzle();
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    callback();
                }
            }
            requestAnimationFrame(animate);
        }

        // =====================================================================
        // Update Move Counter
        // =====================================================================
        function updateMoveCounter() {
            moveCounterDisplay.textContent = moves;
        }

        // =====================================================================
        // Timer Functions
        // =====================================================================
        function startTimer() {
            stopTimer();
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function updateTimer() {
            const elapsedTime = Date.now() - startTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const formattedMinutes = String(minutes).padStart(2, '0');
            const formattedSeconds = String(seconds).padStart(2, '0');

            timerDisplay.textContent = `${formattedMinutes}:${formattedSeconds}`;
        }

        // =====================================================================
        // Check Win Condition & Display Win Animation
        // =====================================================================
        function checkWin() {
            if (!isShuffled) return;
            let solved = true;
            for (let i = 0; i < puzzlePieces.length; i++) {
                const piece = puzzlePieces[i];
                // Check if the piece is in its correct original position
                const currentPieceCol = Math.round(piece.currentX / pieceWidth);
                const currentPieceRow = Math.round(piece.currentY / pieceHeight);
                const currentPieceIndex = currentPieceRow * gridSize + currentPieceCol;
                if (piece.id !== currentPieceIndex) {
                    solved = false;
                    break;
                }
            }

            if (solved) {
                isShuffled = false;
                stopTimer();
                hasMadeFirstMove = false; // Reset first move flag

                // Ensure the blank piece is visually at the last position for a truly solved look
                const blankPiece = puzzlePieces.find(p => p.isBlank);
                const blankPieceCurrentIndexInArray = puzzlePieces.indexOf(blankPiece);
                const lastCorrectArrayPosition = puzzlePieces.length - 1;
                if (blankPieceCurrentIndexInArray !== lastCorrectArrayPosition) {
                    const pieceAtLastPosition = puzzlePieces[lastCorrectArrayPosition];
                    puzzlePieces[lastCorrectArrayPosition] = blankPiece;
                    puzzlePieces[blankPieceCurrentIndexInArray] = pieceAtLastPosition;

                    blankPiece.currentX = (lastCorrectArrayPosition % gridSize) * pieceWidth;
                    blankPiece.currentY = Math.floor(lastCorrectArrayPosition / gridSize) * pieceHeight;
                    pieceAtLastPosition.currentX = (blankPieceCurrentIndexInArray % gridSize) * pieceWidth;
                    pieceAtLastPosition.currentY = Math.floor(blankPieceCurrentIndexInArray / gridSize) * pieceHeight;
                }
                
                drawPuzzle();
                puzzleCanvas.classList.add('puzzle-solved-animation'); // Apply bounce animation
                
                showMessageBox(`Selamat! Puzzle telah selesai dalam ${moves} gerakan dan waktu ${timerDisplay.textContent}!`);
                
                enableAllButtons();
                solving = false;
                shuffling = false;
                isProcessingClick = false;
                
                // Show replay button if there are moves to replay
                if (replayMoves.length > 0) {
                    replayButton.style.display = 'inline-block';
                }
            }
        }

        // =====================================================================
        // Disable all interactive buttons
        // =====================================================================
        function disableAllButtons() {
            shuffleButton.disabled = true;
            undoButton.disabled = true;
            solveButton.disabled = true;
            resetButton.disabled = false; // Reset button always remains active
            imageUpload.disabled = true;
            gridSizeSelect.disabled = true;
            puzzleModeSelect.disabled = true;
            viewOriginalImageButton.disabled = true;
            replayButton.disabled = true; // Disable replay button during operations
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'none');
            sampleImageContainers.forEach(container => container.style.opacity = '0.5');
        }

        // =====================================================================
        // Enable all interactive buttons
        // =====================================================================
        function enableAllButtons() {
            shuffleButton.disabled = false;
            undoButton.disabled = false;
            solveButton.disabled = false; 
            resetButton.disabled = false;
            imageUpload.disabled = false;
            gridSizeSelect.disabled = false;
            puzzleModeSelect.disabled = false;
            viewOriginalImageButton.disabled = false;
            replayButton.disabled = false; // Enable replay button
            sampleImageContainers.forEach(container => container.style.pointerEvents = 'auto');
            sampleImageContainers.forEach(container => container.style.opacity = '1');
        }

        // =====================================================================
        // Function to auto-solve puzzle using BFS (Breadth-First Search)
        // =====================================================================
        solveButton.addEventListener('click', () => {
            showConfirmationBox("Apakah Anda ingin puzzle diselesaikan secara otomatis? Ini akan mereset gerakan Anda.", async () => {
                await solvePuzzleAutomatically();
            });
        });

        async function solvePuzzleAutomatically() {
            if (!puzzleReady || !isShuffled || solving || shuffling || isReplaying) { // Disable during replay
                return;
            }

            solving = true;
            isProcessingClick = true;
            hasMadeFirstMove = true; // Auto-solve implies moves are being made, so start timer
            startTimer();
            if (gridSize === 5) {
                showLoading(`Peringatan: 5x5 Otomatis Sangat Lambat! Harap Bersabar.`);
            } else {
                showLoading(`Mencari solusi otomatis...`);
            }
            
            disableAllButtons();
            resetButton.disabled = false;

            stopTimer(); // Temporarily stop timer during search, will restart for animation playback

            const queue = [];
            const visited = new Set();

            // Create a state array based on current positions (map original IDs to their current 1D index)
            const initialPiecesState = puzzlePieces.map(p => {
                const col = Math.round(p.currentX / pieceWidth);
                const row = Math.round(p.currentY / pieceHeight);
                return { id: p.id, currentPos: row * gridSize + col };
            });
            initialPiecesState.sort((a, b) => a.currentPos - b.currentPos); // Sort by current position to get current "reading" order

            const initialOrderedIds = initialPiecesState.map(p => p.id);
            const blankId = puzzlePieces.find(p => p.isBlank).id;
            const initialBlankPos = initialOrderedIds.indexOf(blankId);

            queue.push({ state: initialOrderedIds, path: [], blankPos: initialBlankPos });
            visited.add(JSON.stringify(initialOrderedIds));
            let solutionPath = null;
            let count = 0; 

            while (queue.length > 0 && solving && count < maxStatesToExploreForBFS) {
                const { state, path, blankPos } = queue.shift();
                count++;

                const isSolved = state.every((id, index) => id === index);
                if (isSolved) {
                    solutionPath = path;
                    break;
                }

                const blankRow = Math.floor(blankPos / gridSize);
                const blankCol = blankPos % gridSize;

                const possibleSwapPositions = [];
                // Check neighbors: Up, Down, Left, Right
                if (blankRow > 0) possibleSwapPositions.push(blankPos - gridSize);
                if (blankRow < gridSize - 1) possibleSwapPositions.push(blankPos + gridSize); 
                if (blankCol > 0) possibleSwapPositions.push(blankPos - 1);
                if (blankCol < gridSize - 1) possibleSwapPositions.push(blankPos + 1); 

                for (const pieceToSwapIndex of possibleSwapPositions) {
                    const nextState = [...state];
                    // Swap the IDs in the new state array
                    const tempId = nextState[blankPos];
                    nextState[blankPos] = nextState[pieceToSwapIndex];
                    nextState[pieceToSwapIndex] = tempId;

                    const nextStateStr = JSON.stringify(nextState);
                    if (!visited.has(nextStateStr)) {
                        visited.add(nextStateStr);
                        queue.push({
                            state: nextState,
                            path: [...path, state[pieceToSwapIndex]], // Store the ID of the piece that moved into the blank spot
                            blankPos: pieceToSwapIndex 
                        });
                    }
                }
                if (count % 1000 === 0) { 
                    await new Promise(resolve => setTimeout(resolve, 0));
                    if (!solving) break; 
                }
            }

            hideLoading();

            if (!solving) { // If user cancelled auto-solve
                solveStatusDisplay.textContent = '';
                stopTimer();
                hasMadeFirstMove = false;
                return;
            }

            if (solutionPath) {
                solveStatusDisplay.textContent = `Solusi ditemukan! Memainkan ${solutionPath.length} gerakan...`;
                const currentAutoSolveDelay = getAutoSolveStepDelay(gridSize);
                
                // Reset moves and replay history for auto-solve
                moves = 0;
                replayMoves = [];
                initialShuffledStateForReplay = []; // Clear initial state for auto-solve replay
                replayButton.style.display = 'none'; // Hide replay button
                moveHistory = []; // Reset move history
                renderMoveHistory(); // Update UI

                // Re-start timer for animation playback
                startTimer();
                for (const pieceIdToMove of solutionPath) {
                    if (!solving) break; // Allow cancellation during playback

                    const pieceToMove = puzzlePieces.find(p => p.id === pieceIdToMove);
                    const blankPiece = puzzlePieces.find(p => p.isBlank);

                    if (!pieceToMove || !blankPiece) { 
                        console.error("Terjadi kesalahan saat memainkan solusi.");
                        solving = false;
                        isProcessingClick = false;
                        enableAllButtons();
                        solveStatusDisplay.textContent = 'Terjadi kesalahan saat memainkan solusi.';
                        stopTimer(); // Stop timer on error
                        hasMadeFirstMove = false;
                        return;
                    }
                    
                    const startX1 = pieceToMove.currentX;
                    const startY1 = pieceToMove.currentY;
                    const startX2 = blankPiece.currentX;
                    const startY2 = blankPiece.currentY;

                    const targetX1 = startX2; 
                    const targetY1 = startY2;
                    const targetX2 = startX1; 
                    const targetY2 = startY1; 

                    await new Promise(resolve => {
                        animatePieceMove(
                            pieceToMove, targetX1, targetY1,
                            blankPiece, targetX2, targetY2,
                            () => {
                                pieceToMove.currentX = targetX1;
                                pieceToMove.currentY = targetY1;
                                blankPiece.currentX = targetX2;
                                blankPiece.currentY = targetY2;

                                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                                const blankIndexInArray = puzzlePieces.indexOf(blankPiece);
                                [puzzlePieces[pieceToMoveCurrentIndex], puzzlePieces[blankIndexInArray]] =
                                [puzzlePieces[blankIndexInArray], puzzlePieces[pieceToMoveCurrentIndex]];

                                moves++;
                                updateMoveCounter();
                                drawPuzzle();
                                resolve();
                            }
                        );
                    });
                    if (solving) { // Only pause if solving is still active
                        await new Promise(resolve => setTimeout(resolve, currentAutoSolveDelay));
                    }
                }
                if (solving) {
                    checkWin(); // Final check if solution playback completed
                }
            } else { 
                solveStatusDisplay.textContent = 'Solusi tidak ditemukan dalam batas waktu/komputasi. Coba acak ulang.';
                showMessageBox('Solusi tidak ditemukan dalam batas waktu atau terlalu kompleks. Coba acak ulang puzzle atau pilih ukuran yang lebih kecil.');
            }

            solving = false;
            isProcessingClick = false;
            enableAllButtons();
            // Timer is handled by checkWin or explicitly stopped on failure/cancellation
            if (isShuffled && !solving) { // If still shuffled and not in an active solve state
                startTimer(); // Ensure timer continues if not solved
            } else if (!isShuffled && !solving) { // If solved, ensure timer is stopped
                stopTimer();
                hasMadeFirstMove = false;
            }
        }
        
        // =====================================================================
        // Replay Functionality
        // =====================================================================
        replayButton.addEventListener('click', async () => {
            if (replayMoves.length === 0 || solving || shuffling || isProcessingClick) {
                showMessageBox("Tidak ada gerakan untuk diputar ulang.");
                return;
            }

            isReplaying = true; // Set replay flag
            disableAllButtons(); // Disable all buttons
            stopTimer(); // Stop timer during replay
            solveStatusDisplay.textContent = 'Memutar ulang...'; // Keep this status, but no overlay

            // Reset puzzle to the initial shuffled state
            puzzlePieces = initialShuffledStateForReplay.map(p => ({ ...p }));
            puzzlePieces.forEach((piece, index) => {
                piece.currentX = (index % gridSize) * pieceWidth;
                piece.currentY = Math.floor(index / gridSize) * pieceHeight;
            });
            moves = 0;
            updateMoveCounter();
            drawPuzzle();
            puzzleCanvas.classList.remove('puzzle-solved-animation');

            // Play back the moves
            for (const move of replayMoves) {
                if (!isReplaying) break; // Allow stopping replay if needed

                const pieceToMove = puzzlePieces.find(p => p.id === move.pieceId);
                const blankPiece = puzzlePieces.find(p => p.isBlank);

                if (!pieceToMove || !blankPiece) {
                    console.error("Error during replay: Piece or blank not found.");
                    break;
                }

                // Find current positions of pieceToMove and blankPiece in the array
                const pieceToMoveCurrentIndex = puzzlePieces.indexOf(pieceToMove);
                const blankPieceCurrentIndex = puzzlePieces.indexOf(blankPiece);

                // Calculate target positions based on the recorded move (fromIndex of the piece moved into blank)
                // The blank piece moves to the pieceToMove's original spot
                // The pieceToMove moves to the blank's original spot
                const targetXForMovedPiece = (move.toIndex % gridSize) * pieceWidth;
                const targetYForMovedPiece = Math.floor(move.toIndex / gridSize) * pieceHeight;
                const targetXForBlank = (move.fromIndex % gridSize) * pieceWidth;
                const targetYForBlank = Math.floor(move.fromIndex / gridSize) * pieceHeight;

                await new Promise(resolve => {
                    animatePieceMove(
                        pieceToMove, targetXForMovedPiece, targetYForMovedPiece,
                        blankPiece, targetXForBlank, targetYForBlank,
                        () => {
                            // Update actual positions after animation
                            pieceToMove.currentX = targetXForMovedPiece;
                            pieceToMove.currentY = targetYForMovedPiece;
                            blankPiece.currentX = targetXForBlank;
                            blankPiece.currentY = targetYForBlank;

                            // Swap their positions in the array
                            const newPieceToMoveIndex = puzzlePieces.indexOf(pieceToMove); // Should be blankPieceCurrentIndex
                            const newBlankPieceIndex = puzzlePieces.indexOf(blankPiece); // Should be pieceToMoveCurrentIndex
                            [puzzlePieces[newPieceToMoveIndex], puzzlePieces[newBlankPieceIndex]] =
                            [puzzlePieces[newBlankPieceIndex], puzzlePieces[newPieceToMoveIndex]];

                            moves++; // Increment moves for replay visual, though not actual game moves
                            updateMoveCounter();
                            drawPuzzle();
                            resolve();
                        }
                    );
                });
                await new Promise(resolve => setTimeout(resolve, 300)); // Delay between replay moves
            }

            isReplaying = false; // Reset replay flag
            solveStatusDisplay.textContent = 'Pemutaran ulang selesai.';
            // After replay, the puzzle should be solved
            checkWin(); // This will re-enable buttons and handle final state
        });


        // =====================================================================
        // Handle Window Resize Responsiveness
        // =====================================================================
        window.addEventListener('resize', async () => {
            if (!puzzleReady) return; // Don't do anything if puzzle isn't ready

            solving = false;
            isProcessingClick = false;
            isReplaying = false; // Stop replay on resize
            
            enableAllButtons(); // Re-enable in case they were disabled by auto-solve/click animation
            solveStatusDisplay.textContent = '';
            puzzleCanvas.classList.remove('puzzle-solved-animation');

            recalculatePiecePositionsAndRedraw(); // Always redraw to fit new canvas size, preserving current state
        });
        // =====================================================================
        // Local Storage Functions for Preferences
        // =====================================================================
        function savePreferences() {
            localStorage.setItem('puzzleGridSize', gridSizeSelect.value);
            localStorage.setItem('puzzleMode', puzzleModeSelect.value);
        }

        function loadPreferences() {
            const savedGridSize = localStorage.getItem('puzzleGridSize');
            const savedPuzzleMode = localStorage.getItem('puzzleMode');

            if (savedGridSize) {
                gridSizeSelect.value = savedGridSize;
                gridSize = parseInt(savedGridSize);
            }
            if (savedPuzzleMode) {
                puzzleModeSelect.value = savedPuzzleMode;
                currentPuzzleMode = savedPuzzleMode;
            }
        }

        // =====================================================================
        // Handle "View Original Image" Button
        // =====================================================================
        viewOriginalImageButton.addEventListener('click', () => {
            if (originalImage.src) {
                mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
                originalImageDisplayContainer.classList.add('show'); // Show original image container
                fullImageDisplay.src = originalImage.src; // Ensure image is displayed
                // Scroll to the top of the original image container
                originalImageDisplayContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                showMessageBox("Tidak ada gambar yang dimuat untuk ditampilkan.");
            }
        });
        backToPuzzleButton.addEventListener('click', () => {
            originalImageDisplayContainer.classList.remove('show'); // Hide original image container
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            // Scroll to the puzzle canvas for better context
            puzzleCanvas.scrollIntoView({ behavior: 'smooth', block: 'center' }); // block: 'center' tries to center it
        });

        // =====================================================================
        // Image Cropper Logic
        // =====================================================================
        function setupCroppingInterface() {
            mainContent.classList.add('main-content-hidden'); // Hide main puzzle UI
            imageCropperContainer.style.display = 'flex'; // Show cropper modal

            // Set cropper canvas dimensions to fit the image while maintaining aspect ratio
            const maxWidth = cropperCanvas.parentElement.clientWidth * 0.9;
            const maxHeight = window.innerHeight * 0.7; // Max 70% of viewport height for cropper image
            
            let imgRatio = originalImage.width / originalImage.height;
            let canvasWidth = originalImage.width;
            let canvasHeight = originalImage.height;

            if (canvasWidth > maxWidth) {
                canvasWidth = maxWidth;
                canvasHeight = canvasWidth / imgRatio;
            }
            if (canvasHeight > maxHeight) {
                canvasHeight = maxHeight;
                canvasWidth = canvasHeight * imgRatio;
            }

            cropperCanvas.width = canvasWidth;
            cropperCanvas.height = canvasHeight;

            // Initialize cropRect to a default square in the center
            const minDim = Math.min(cropperCanvas.width, cropperCanvas.height);
            cropRect.size = minDim * 0.8; // Start with 80% of the smaller dimension
            cropRect.x = (cropperCanvas.width / 2) - (cropRect.size / 2);
            cropRect.y = (cropperCanvas.height / 2) - (cropRect.size / 2);

            drawCropper();

            // Enable buttons
            confirmCropButton.disabled = false;
            cancelCropButton.disabled = false;
        }

        function drawCropper() {
            cropperCtx.clearRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            cropperCtx.drawImage(originalImage, 0, 0, cropperCanvas.width, cropperCanvas.height);

            // Draw overlay (darkened outside cropRect)
            cropperCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            cropperCtx.fillRect(0, 0, cropperCanvas.width, cropperCanvas.height);
            // Draw transparent hole for the crop area
            cropperCtx.globalCompositeOperation = 'destination-out';
            cropperCtx.fillRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);
            cropperCtx.globalCompositeOperation = 'source-over'; // Reset composite operation

            // Draw crop rectangle border
            cropperCtx.strokeStyle = '#fff';
            cropperCtx.lineWidth = 2;
            ctx.strokeRect(piece.currentX, piece.currentY, pieceWidth, pieceHeight);
            cropperCtx.strokeRect(cropRect.x, cropRect.y, cropRect.size, cropRect.size);

            // Draw resize handles (corners)
            cropperCtx.fillStyle = '#6366f1';
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Top-left
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Top-right
            cropperCtx.fillRect(cropRect.x - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Bottom-left
            cropperCtx.fillRect(cropRect.x + cropRect.size - resizeHandleSize / 2, cropRect.y + cropRect.size - resizeHandleSize / 2, resizeHandleSize, resizeHandleSize); // Bottom-right
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) * (canvas.width / rect.width),
                y: (evt.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        function getTouchPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const touch = evt.touches[0];
            return {
                x: (touch.clientX - rect.left) * (canvas.width / rect.width),
                y: (touch.clientY - rect.top) * (canvas.height / rect.height)
            };
        }

        cropperCanvas.addEventListener('mousedown', handleCropStart);
        cropperCanvas.addEventListener('mousemove', handleCropMove);
        cropperCanvas.addEventListener('mouseup', handleCropEnd);
        cropperCanvas.addEventListener('mouseleave', handleCropEnd); // End drag if mouse leaves canvas

        cropperCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleCropStart(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleCropMove(e.touches[0]); }, { passive: false });
        cropperCanvas.addEventListener('touchend', handleCropEnd);

        function handleCropStart(e) {
            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            dragStartX = pos.x;
            dragStartY = pos.y;

            // Check if resizing handle is clicked (bottom-right corner)
            if (pos.x > cropRect.x + cropRect.size - resizeHandleSize && pos.x < cropRect.x + cropRect.size + resizeHandleSize &&
                pos.y > cropRect.y + cropRect.size - resizeHandleSize && pos.y < cropRect.y + cropRect.size + resizeHandleSize) {
                isResizing = true;
            } else if (pos.x > cropRect.x && pos.x < cropRect.x + cropRect.size &&
                       pos.y > cropRect.y && pos.y < cropRect.y + cropRect.size) {
                isDragging = true;
            }
        }

        function handleCropMove(e) {
            if (!isDragging && !isResizing) return;

            const pos = e.touches ? getTouchPos(cropperCanvas, e) : getMousePos(cropperCanvas, e);
            const dx = pos.x - dragStartX;
            const dy = pos.y - dragStartY;

            if (isDragging) {
                cropRect.x += dx;
                cropRect.y += dy;

                // Keep cropRect within canvas bounds
                cropRect.x = Math.max(0, Math.min(cropRect.x, cropperCanvas.width - cropRect.size));
                cropRect.y = Math.max(0, Math.min(cropRect.y, cropperCanvas.height - cropRect.size));
            } else if (isResizing) {
                let newSize = Math.max(20, cropRect.size + dx); // Minimum size 20px
                newSize = Math.max(newSize, cropRect.size + dy); // Use larger delta for square resize

                // Ensure cropRect stays within canvas bounds during resize
                newSize = Math.min(newSize, cropperCanvas.width - cropRect.x);
                newSize = Math.min(newSize, cropperCanvas.height - cropRect.y);

                cropRect.size = newSize;
            }

            dragStartX = pos.x;
            dragStartY = pos.y;

            drawCropper();
        }

        function handleCropEnd() {
            isDragging = false;
            isResizing = false;
        }

        confirmCropButton.addEventListener('click', () => {
            // Calculate final source dimensions for the original image
            const scaleX = originalImage.width / cropperCanvas.width;
            const scaleY = originalImage.height / cropperCanvas.height;

            finalSourceX = cropRect.x * scaleX;
            finalSourceY = cropRect.y * scaleY;
            finalSourceWidth = cropRect.size * scaleX;
            finalSourceHeight = cropRect.size * scaleY; // Always square, so height = width

            imageCropperContainer.style.display = 'none'; // Hide cropper modal
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            
            initializePuzzle(finalSourceX, finalSourceY, finalSourceWidth, finalSourceHeight);
            animateShuffle(); // Shuffle after cropping and initializing
            enableAllButtons(); // Re-enable main buttons
        });

        cancelCropButton.addEventListener('click', () => {
            imageCropperContainer.style.display = 'none'; // Hide cropper modal
            mainContent.classList.remove('main-content-hidden'); // Show main puzzle UI
            showMessageBox("Pemotongan dibatalkan. Silakan unggah atau pilih gambar lain.");
            // Reset to placeholder if no image was previously loaded, or just enable buttons
            if (!puzzleReady) {
                const placeholderSize = fixedCanvasSize;
                originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`;
            }
            enableAllButtons();
        });

        // =====================================================================
        // Move History Functionality
        // =====================================================================
        function addMoveToHistory(pieceNumber, fromIndex, toIndex, currentGridSize) {
            const fromRow = Math.floor(fromIndex / currentGridSize);
            const fromCol = fromIndex % currentGridSize;
            const toRow = Math.floor(toIndex / currentGridSize);
            const toCol = toIndex % currentGridSize;

            let direction = '';
            if (fromRow === toRow) { // Horizontal move
                direction = fromCol < toCol ? 'Kanan' : 'Kiri';
            } else { // Vertical move
                direction = fromRow < toRow ? 'Bawah' : 'Atas';
            }

            const moveText = `Potongan ${pieceNumber} bergerak ${direction}`;
            moveHistory.unshift(moveText); // Add to the beginning
            if (moveHistory.length > maxMoveHistory) {
                moveHistory.pop(); // Remove oldest if exceeding limit
            }
            renderMoveHistory();
        }

        function renderMoveHistory() {
            moveHistoryList.innerHTML = '';
            if (moveHistory.length === 0) {
                moveHistoryList.innerHTML = '<li class="text-center text-gray-500">Belum ada gerakan.</li>';
                return;
            }
            moveHistory.forEach(move => {
                const listItem = document.createElement('li');
                listItem.textContent = move;
                moveHistoryList.appendChild(listItem);
            });
        }

        // =====================================================================
        // Initial Page Load Setup (placeholder image)
        // =====================================================================
        window.onload = async () => {
            loadPreferences(); // Load saved preferences first

            originalImage.onload = async () => {
                // If the image is already square, directly initialize and shuffle
                if (originalImage.width === originalImage.height) {
                    initializePuzzle(0, 0, originalImage.width, originalImage.height);
                    await animateShuffle();
                } else {
                    // Otherwise, show the cropping interface
                    setupCroppingInterface();
                }
            };
            const placeholderSize = fixedCanvasSize; 
            originalImage.src = `https://placehold.co/${placeholderSize}x${placeholderSize}/e0e7ff/4f46e5?text=Unggah%20Foto%0A(${gridSize}x${gridSize})`; 
        };

    </script>
</body>
</html>
